include::ROOT:partial$attributes.adoc[]

= Best Practices and Recipes

A collection of tips and code snippets designed to help you write cleaner, more optimised Cerbos policies.

== Modelling policies

The way you model your policies is up you -- you can achieve the same logical outcome in numerous ways. That said, some patterns will lend themselves more naturally to certain scenarios.

Consider this business model:

[%noheader,cols="2h,5*^"]
|===
^e|Actions
5+e|Roles
|
h|IT_ADMIN
h|JR_MANAGER
h|SR_MANAGER
h|USER
h|CFO
|run    |         |x          |x          |     |x
|view   |x        |x          |x          |x    |x
|edit   |         |           |x          |     |x
|save   |         |           |x          |     |x
|share  |         |x          |x          |     |x
|===

Representing this as a resource policy could be achieved in a variety of ways. Let's take a look at each:

=== Action-led

Here, we focus on an action, and list all the roles that can perform that action:

[source,yaml,linenums]
----
# Principals in the following three roles can perform the `run` action
  - actions:
      - "run"
    effect: EFFECT_ALLOW
    roles:
      - JR_MANAGER
      - SR_MANAGER
      - CFO

# All principals can perform the `view` action
  - actions:
      - "view"
    effect: EFFECT_ALLOW
    roles:
      - ["*"]
----

This approach might be suitable if any of the following apply to your system:

* Your roles are "similar" in what they can do like `JR_MANAGER` and `SR_MANAGER`; it's likely that `JR_MANAGER` will have a subset of the permissions of `SR_MANAGER`. There will of course be duplication in either direction, but it's often easier to reason about this from an action perspective.
* You have "high-risk" actions -- you want to be able to tell at a glance which roles have access to a particular action. The act of explicitly listing roles per action makes it much more difficult to accidentally give unwanted permissions to the wrong user.
* You have a relatively high number of roles to a low number of actions.

=== Role-led

Alternatively, we can focus on a role, and list all the actions the role can perform:

[source,yaml,linenums]
----
# These three actions can be performed by principals in the `JR_MANAGER` role
  - actions:
      - "run"
      - "view"
      - "share"
    effect: EFFECT_ALLOW
    roles:
      - JR_MANAGER
----

You might opt for a role-led approach if:

* You have distinct roles where it's rare for your roles to share common actions.
* You have a relatively low number of roles to a high number of actions.

=== Hybrid

Perhaps we want to use a combination of the two:

[source,yaml,linenums]
----
# Principals in the `SR_MANAGER` or `CFO` roles can perform all actions
  - actions:
      - "*"
    effect: EFFECT_ALLOW
    roles:
      - SR_MANAGER
      - CFO
----

This might apply if your scenario doesn't strictly fall into one of the previous two sections; individually, or at all.

=== Blanket allow, granular deny

Finally, we can opt to explicitly state which actions a user *cannot* do:

[source,yaml,linenums]
----
# Principals in the `JR_MANAGER` role can perform all actions, other than `edit` and `save`
  - actions:
      - "*"
    effect: EFFECT_ALLOW
    roles:
      - "JR_MANAGER"

  - actions:
      - "edit"
      - "save"
    effect: EFFECT_DENY
    roles:
      - "JR_MANAGER"
----

This would suit scenarios where a principal can perform _nearly_ every action, and you want to explicitly list disallowed actions.

=== Resource-led

Arguably, all Cerbos policies are inherently _resource-led_, but you can opt to approach policy design with a stronger bias towards the resources within your system, rather than by initially considering _who_ is accessing them and _what_ they can do.

Consider the following hypothetical scenario; you are responsible for creating and managing access to a new analytical reports screen. Perhaps this is a UI showing a specific metric relating to your business. How you'd approach this would be heavily influenced by your organizational structure, or the context:

**Action/role-biased:**

* You have specific (possibly non-technical) personnel or departments responsible for managing access to applications and resources globally.
* These applications are probably built by other engineering teams.
* The new report in question is an addition to a pre-existing dashboard, and access is common between all reports in that dashboard.

In this situation, it's likely that the resource policy has already been written, so handling this new report is as simple as it assuming the existing resource `kind`.

**Resource-biased:**

* You are a developer or technically-minded person responsible for building and managing applications in the system, as well as writing the policies to govern access.
* The new report is unique, and doesn't share similarities with other pre-existing UIs; maybe it's a one-off UI which has been built as a temporary demo to a varied audience.

In this situation, you'll want to define a new resource policy and then explicitly define who can access it. Given that the policy will map to very few resources (1, in this scenario), it'll likely only require minimal configuration data, but _will_ need a method to map to the unique resource. The policy below shows how this can be done via a list attribute passed in the request:

[source,yaml,linenums]
----
---
apiVersion: api.cerbos.dev/v1
resourcePolicy:
  version: default
  resource: report
  rules:
    - actions: ["view"]
      effect: EFFECT_ALLOW
      roles:
        - user
      condition:
        match:
          expr: "demo_001" in request.principal.attr.demos
----

Note: there are numerous ways of mapping access to this resource. You could use a temporary role (handled and administered in the application layer), xref:policies:derived_roles.adoc[derived roles], or via other attribute-based methods.

== Map of relations

Avoiding complex query planner outputs with sub-expressions:

.Before
[source,yaml,linenums]
----
apiVersion: api.cerbos.dev/v1
resourcePolicy:
  resource: example_resource
  version: default
  rules:
    - actions:
        - "*"
      effect: EFFECT_ALLOW
      roles:
        - USER
      condition:
        match:
          expr: P.attr.relations[R.id] == "owner"
----

Notice how, in the above match condition, we reference both the Principal and the Resource within a single struct indexing expression: `P.attr.relations[R.id]`. This is correct both syntactically and logically. However, when using the `PlanResources` API to produce a query plan, the generated plan can sometimes be quite complicated due to how these expressions are represented internally.


To improve this, we can apply a little bit of mechanical-sympathy and rewrite the expression in a way where the known values (principal attributes) are separated from unknown values (resource attributes) as follows:

.After
[source,yaml,linenums]
----
apiVersion: api.cerbos.dev/v1
resourcePolicy:
  resource: example_resource
  version: default
  rules:
    - actions:
        - "*"
      effect: EFFECT_ALLOW
      roles:
        - USER
      condition:
        match:
          expr: R.id in P.attr.relations.filter(x, P.attr.relations[x] == "owner")
----

== Adding self-service custom roles

Imagine this scenario: you're an admin in a multi-tenant system, and you want a method by which you can copy an existing role, and then select which permissions/actions to enable or disable for each.

There are two ways of approaching this:

=== Static Policies / Dynamic Context

This is the _idiomatic_ way of solving this use-case in Cerbos. In the vast majority of cases, it is possible to have the policies statically defined and to pass in dynamic context as attributes of a principal. This dynamic context can be any arbitrary data such as the principal's location, age, or specific roles it has within the context of an organizational unit (a department, a tenant or a project, for example). This contextual data would be retrieved at request time from another service or a data store. Let's look at an example.

Here is a resource policy for a resource of type `"workspace"`:

.workspace.yaml
[source,yaml,linenums]
----
apiVersion: "api.cerbos.dev/v1"
resourcePolicy:
  version: "default"
  resource: "workspace"
  rules:
    - actions:
        - workspace:view
        - pii:view
      effect: EFFECT_ALLOW
      roles:
        - USER
      condition:
        match:
          expr: P.attr.workspaces[R.id].role == "OWNER"
----

Notice how the condition relies on context passed in within the `P.attr.workspaces` map, with the key being the resource ID, and the value being a predefined value `"OWNER"`. We can grant access to a principal with the `USER` role, by constructing the following request payload:

[tabs]
====
cURL::
+
--
[source,shell,linenums]
----
include::example$curl.txt[]
----
--
.NET::
+
--
[source,csharp,linenums]
----
include::example$example.cs[]
----
--
Go::
+
--
[source,go,linenums]
----
include::example$example.go[]
----
--
Java::
+
--
[source,java,linenums]
----
include::example$example.java[]
----
--
JS::
+
--
[source,javascript,linenums]
----
include::example$example.js[]
----
--
PHP::
+
--
[source,php,linenums]
----
include::example$example.php[]
----
--
Python::
+
--
[source,python,linenums]
----
include::example$example.py[]
----
--
Ruby::
+
--
[source,ruby,linenums]
----
include::example$example.rb[]
----
--
Rust::
+
--
[source,rust,linenums]
----
include::example$example.rs[]
----
--
====

You can find a full (and extended) example of the above in our https://play.cerbos.dev/p/IJxlK6131f642ND65F1EhPmiT18Ap1A5[SaaS Workspace Policy playground example].

=== Dynamic Policies

There might be circumstances where you want to create or update resources and actions on the fly; an example of this might be a multi-tenant platform that provides tenants the ability to manage their own policies.

If this is the case, then you can use the xref:api:admin_api.adoc[Admin API] configured alongside a mutable xref:configuration:storage.adoc#sqlite3[database storage engine] to provide this functionality. This would be handled within your application layer, with the desired policy contents provided to the PDP via the API.

For a full example implementation, check out https://github.com/cerbos/demo-admin-api[this demo].
