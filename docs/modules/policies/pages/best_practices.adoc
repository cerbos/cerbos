include::ROOT:partial$attributes.adoc[]

= Best Practices

A collection of tips and code snippets designed to help you write cleaner, more optimised Cerbos policies.

== Modelling policies

The way you model your policies is up you - you can achieve the same logical outcome in _many_ ways. That said, some patterns will lend themselves more naturally to certain scenarios. Consider this business model:

[%noheader,cols="2h,5*^"]
|===
^e|Actions
5+e|Roles
|
h|IT_ADMIN
h|JR_MANAGER
h|SR_MANAGER
h|USER
h|CFO
|run    |         |x          |x          |     |x
|view   |x        |x          |x          |x    |x
|edit   |         |           |x          |     |x
|save   |         |           |x          |     |x
|share  |         |x          |x          |     |x
|===

Representing this as a resource policy could be achieved in a variety of ways. Let's take a look at each:

=== Action-led

Here, we focus on an action, and list all the roles that can perform that action:

[source,yaml,linenums]
----
# Principals in the following three roles can perform the `run` action
  - actions:
      - "run"
    effect: EFFECT_ALLOW
    roles:
      - JR_MANAGER
      - SR_MANAGER
      - CFO

# All principals can perform the `view` action
  - actions:
      - "view"
    effect: EFFECT_ALLOW
    roles:
      - ["*"]
----

This approach might be suitable if either of the following apply to your system:

* Your roles are "similar" in what they can do, e.g. `JR_MANAGER` and `SR_MANAGER`; it's likely that `JR_MANAGER` will have a subset of the permissions of `SR_MANAGER`. There will of course be duplication in either direction, but it's often easier to reason about this from an action perspective.
* You have "high-risk" actions - you want to be able to tell at a glance which roles have access to a particular action. The act of explicitly listing roles per action makes it much more difficult to accidentally give permission to an unwanted user.
* You have a relatively high number of roles to a low number of actions.

=== Role-led

Or we can focus on a role, and list all the actions the role can perform:

[source,yaml,linenums]
----
# These three actions can be performed by principals in the `JR_MANAGER` role
  - actions:
      - "run"
      - "view"
      - "share"
    effect: EFFECT_ALLOW
    roles:
      - JR_MANAGER
----

You might opt for a role-led approach if:

* You have distinct roles, e.g. it's rare for your roles to share common actions.
* You have a relatively low number of roles to a high number of actions.

=== Hybrid

Perhaps we want to use a combination of the two:

[source,yaml,linenums]
----
# Principals in the `SR_MANAGER` or `CFO` roles can perform all actions
  - actions:
      - "*"
    effect: EFFECT_ALLOW
    roles:
      - SR_MANAGER
      - CFO
----

This might apply if your scenario doesn't strictly fall into one of the previous two sections, individually (or at all).

=== Blanket allow, granular deny

Or we can opt to explicitly state which actions a user *cannot* do:

[source,yaml,linenums]
----
# Principals in the `JR_MANAGER` role can perform all actions, other than `edit` and `save`
  - actions:
      - "*"
    effect: EFFECT_ALLOW
    roles:
      - "JR_MANAGER"

  - actions:
      - "edit"
      - "save"
    effect: EFFECT_DENY
    roles:
      - "JR_MANAGER"
----

This would suit scenarios where a principal can perform _nearly_ every action.

Which approach you take will largely depend on the application itself, but you certainly don't have to abide by any single approach - choose what works best for the given scenario! Do you have key actions over which you want clear and explicit control? Then perhaps the "action-led" approach will fit. Or alternatively, do you want granular control over a particular role? Perhaps your roles have fewer similarities, so explicitly defining each action for each might work better? The "role-led" approach might be the way to go!

== Map of relations

Avoiding complex query planner outputs with pre evaluations:

.Before
[source,yaml,linenums]
----
apiVersion: api.cerbos.dev/v1
resourcePolicy:
  resource: example_resource
  version: default
  rules:
    - actions:
        - "*"
      effect: EFFECT_ALLOW
      roles:
        - USER
      condition:
        match:
          expr: P.attr.relations[R.id] == "owner"
----

//https://github.com/cerbos/cerbos/issues/1263
Notice how, in the above match condition, we reference both the Principal and the Resource within a single struct indexing expression: `P.attr.relations[R.id]`. Syntactically (and logically), this is correct, but in some scenarios (namely, when producing query plans via the `PlanResources` API) can produce overly complex results.

To improve this, we can separate these parts into subexpressions and pre evaluate the respective result sets:

.After
[source,yaml,linenums]
----
apiVersion: api.cerbos.dev/v1
resourcePolicy:
  resource: example_resource
  version: default
  rules:
    - actions:
        - "*"
      effect: EFFECT_ALLOW
      roles:
        - USER
      condition:
        match:
          expr: R.id in P.attr.relations.filter(x, P.attr.relations[x] == "owner")
----
