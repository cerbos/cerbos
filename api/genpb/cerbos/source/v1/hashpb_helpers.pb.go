// Code generated by protoc-gen-go-hashpb. Do not edit.
// protoc-gen-go-hashpb v0.2.0

package sourcev1

import (
	v1 "github.com/cerbos/cerbos/api/genpb/cerbos/policy/v1"
	protowire "google.golang.org/protobuf/encoding/protowire"
	structpb "google.golang.org/protobuf/types/known/structpb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	hash "hash"
	math "math"
	sort "sort"
)

func cerbos_policy_v1_Condition_hashpb_sum(m *v1.Condition, hasher hash.Hash, ignore map[string]struct{}) {
	if m.Condition != nil {
		if _, ok := ignore["cerbos.policy.v1.Condition.condition"]; !ok {
			switch t := m.Condition.(type) {
			case *v1.Condition_Match:
				if t.Match != nil {
					cerbos_policy_v1_Match_hashpb_sum(t.Match, hasher, ignore)
				}

			case *v1.Condition_Script:
				_, _ = hasher.Write(protowire.AppendString(nil, t.Script))

			}
		}
	}
}

func cerbos_policy_v1_DerivedRoles_hashpb_sum(m *v1.DerivedRoles, hasher hash.Hash, ignore map[string]struct{}) {
	if _, ok := ignore["cerbos.policy.v1.DerivedRoles.name"]; !ok {
		_, _ = hasher.Write(protowire.AppendString(nil, m.Name))

	}
	if _, ok := ignore["cerbos.policy.v1.DerivedRoles.definitions"]; !ok {
		if len(m.Definitions) > 0 {
			for _, v := range m.Definitions {
				if v != nil {
					cerbos_policy_v1_RoleDef_hashpb_sum(v, hasher, ignore)
				}

			}
		}
	}
	if _, ok := ignore["cerbos.policy.v1.DerivedRoles.variables"]; !ok {
		if m.Variables != nil {
			cerbos_policy_v1_Variables_hashpb_sum(m.Variables, hasher, ignore)
		}

	}
}

func cerbos_policy_v1_ExportVariables_hashpb_sum(m *v1.ExportVariables, hasher hash.Hash, ignore map[string]struct{}) {
	if _, ok := ignore["cerbos.policy.v1.ExportVariables.name"]; !ok {
		_, _ = hasher.Write(protowire.AppendString(nil, m.Name))

	}
	if _, ok := ignore["cerbos.policy.v1.ExportVariables.definitions"]; !ok {
		if len(m.Definitions) > 0 {
			keys := make([]string, len(m.Definitions))
			i := 0
			for k := range m.Definitions {
				keys[i] = k
				i++
			}

			sort.Slice(keys, func(i, j int) bool { return keys[i] < keys[j] })

			for _, k := range keys {
				_, _ = hasher.Write(protowire.AppendString(nil, m.Definitions[k]))

			}
		}
	}
}

func cerbos_policy_v1_Match_ExprList_hashpb_sum(m *v1.Match_ExprList, hasher hash.Hash, ignore map[string]struct{}) {
	if _, ok := ignore["cerbos.policy.v1.Match.ExprList.of"]; !ok {
		if len(m.Of) > 0 {
			for _, v := range m.Of {
				if v != nil {
					cerbos_policy_v1_Match_hashpb_sum(v, hasher, ignore)
				}

			}
		}
	}
}

func cerbos_policy_v1_Match_hashpb_sum(m *v1.Match, hasher hash.Hash, ignore map[string]struct{}) {
	if m.Op != nil {
		if _, ok := ignore["cerbos.policy.v1.Match.op"]; !ok {
			switch t := m.Op.(type) {
			case *v1.Match_All:
				if t.All != nil {
					cerbos_policy_v1_Match_ExprList_hashpb_sum(t.All, hasher, ignore)
				}

			case *v1.Match_Any:
				if t.Any != nil {
					cerbos_policy_v1_Match_ExprList_hashpb_sum(t.Any, hasher, ignore)
				}

			case *v1.Match_None:
				if t.None != nil {
					cerbos_policy_v1_Match_ExprList_hashpb_sum(t.None, hasher, ignore)
				}

			case *v1.Match_Expr:
				_, _ = hasher.Write(protowire.AppendString(nil, t.Expr))

			}
		}
	}
}

func cerbos_policy_v1_Metadata_hashpb_sum(m *v1.Metadata, hasher hash.Hash, ignore map[string]struct{}) {
	if _, ok := ignore["cerbos.policy.v1.Metadata.source_file"]; !ok {
		_, _ = hasher.Write(protowire.AppendString(nil, m.SourceFile))

	}
	if _, ok := ignore["cerbos.policy.v1.Metadata.annotations"]; !ok {
		if len(m.Annotations) > 0 {
			keys := make([]string, len(m.Annotations))
			i := 0
			for k := range m.Annotations {
				keys[i] = k
				i++
			}

			sort.Slice(keys, func(i, j int) bool { return keys[i] < keys[j] })

			for _, k := range keys {
				_, _ = hasher.Write(protowire.AppendString(nil, m.Annotations[k]))

			}
		}
	}
	if _, ok := ignore["cerbos.policy.v1.Metadata.hash"]; !ok {
		if m.Hash != nil {
			google_protobuf_UInt64Value_hashpb_sum(m.Hash, hasher, ignore)
		}

	}
	if _, ok := ignore["cerbos.policy.v1.Metadata.store_identifer"]; !ok {
		_, _ = hasher.Write(protowire.AppendString(nil, m.StoreIdentifer))

	}
	if _, ok := ignore["cerbos.policy.v1.Metadata.store_identifier"]; !ok {
		_, _ = hasher.Write(protowire.AppendString(nil, m.StoreIdentifier))

	}
	if _, ok := ignore["cerbos.policy.v1.Metadata.source_attributes"]; !ok {
		if m.SourceAttributes != nil {
			cerbos_policy_v1_SourceAttributes_hashpb_sum(m.SourceAttributes, hasher, ignore)
		}

	}
}

func cerbos_policy_v1_Output_hashpb_sum(m *v1.Output, hasher hash.Hash, ignore map[string]struct{}) {
	if _, ok := ignore["cerbos.policy.v1.Output.expr"]; !ok {
		_, _ = hasher.Write(protowire.AppendString(nil, m.Expr))

	}
}

func cerbos_policy_v1_Policy_hashpb_sum(m *v1.Policy, hasher hash.Hash, ignore map[string]struct{}) {
	if _, ok := ignore["cerbos.policy.v1.Policy.api_version"]; !ok {
		_, _ = hasher.Write(protowire.AppendString(nil, m.ApiVersion))

	}
	if _, ok := ignore["cerbos.policy.v1.Policy.disabled"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(nil, protowire.EncodeBool(m.Disabled)))

	}
	if _, ok := ignore["cerbos.policy.v1.Policy.description"]; !ok {
		_, _ = hasher.Write(protowire.AppendString(nil, m.Description))

	}
	if _, ok := ignore["cerbos.policy.v1.Policy.metadata"]; !ok {
		if m.Metadata != nil {
			cerbos_policy_v1_Metadata_hashpb_sum(m.Metadata, hasher, ignore)
		}

	}
	if m.PolicyType != nil {
		if _, ok := ignore["cerbos.policy.v1.Policy.policy_type"]; !ok {
			switch t := m.PolicyType.(type) {
			case *v1.Policy_ResourcePolicy:
				if t.ResourcePolicy != nil {
					cerbos_policy_v1_ResourcePolicy_hashpb_sum(t.ResourcePolicy, hasher, ignore)
				}

			case *v1.Policy_PrincipalPolicy:
				if t.PrincipalPolicy != nil {
					cerbos_policy_v1_PrincipalPolicy_hashpb_sum(t.PrincipalPolicy, hasher, ignore)
				}

			case *v1.Policy_DerivedRoles:
				if t.DerivedRoles != nil {
					cerbos_policy_v1_DerivedRoles_hashpb_sum(t.DerivedRoles, hasher, ignore)
				}

			case *v1.Policy_ExportVariables:
				if t.ExportVariables != nil {
					cerbos_policy_v1_ExportVariables_hashpb_sum(t.ExportVariables, hasher, ignore)
				}

			}
		}
	}
	if _, ok := ignore["cerbos.policy.v1.Policy.variables"]; !ok {
		if len(m.Variables) > 0 {
			keys := make([]string, len(m.Variables))
			i := 0
			for k := range m.Variables {
				keys[i] = k
				i++
			}

			sort.Slice(keys, func(i, j int) bool { return keys[i] < keys[j] })

			for _, k := range keys {
				_, _ = hasher.Write(protowire.AppendString(nil, m.Variables[k]))

			}
		}
	}
	if _, ok := ignore["cerbos.policy.v1.Policy.json_schema"]; !ok {
		_, _ = hasher.Write(protowire.AppendString(nil, m.JsonSchema))

	}
}

func cerbos_policy_v1_PrincipalPolicy_hashpb_sum(m *v1.PrincipalPolicy, hasher hash.Hash, ignore map[string]struct{}) {
	if _, ok := ignore["cerbos.policy.v1.PrincipalPolicy.principal"]; !ok {
		_, _ = hasher.Write(protowire.AppendString(nil, m.Principal))

	}
	if _, ok := ignore["cerbos.policy.v1.PrincipalPolicy.version"]; !ok {
		_, _ = hasher.Write(protowire.AppendString(nil, m.Version))

	}
	if _, ok := ignore["cerbos.policy.v1.PrincipalPolicy.rules"]; !ok {
		if len(m.Rules) > 0 {
			for _, v := range m.Rules {
				if v != nil {
					cerbos_policy_v1_PrincipalRule_hashpb_sum(v, hasher, ignore)
				}

			}
		}
	}
	if _, ok := ignore["cerbos.policy.v1.PrincipalPolicy.scope"]; !ok {
		_, _ = hasher.Write(protowire.AppendString(nil, m.Scope))

	}
	if _, ok := ignore["cerbos.policy.v1.PrincipalPolicy.variables"]; !ok {
		if m.Variables != nil {
			cerbos_policy_v1_Variables_hashpb_sum(m.Variables, hasher, ignore)
		}

	}
}

func cerbos_policy_v1_PrincipalRule_Action_hashpb_sum(m *v1.PrincipalRule_Action, hasher hash.Hash, ignore map[string]struct{}) {
	if _, ok := ignore["cerbos.policy.v1.PrincipalRule.Action.action"]; !ok {
		_, _ = hasher.Write(protowire.AppendString(nil, m.Action))

	}
	if _, ok := ignore["cerbos.policy.v1.PrincipalRule.Action.condition"]; !ok {
		if m.Condition != nil {
			cerbos_policy_v1_Condition_hashpb_sum(m.Condition, hasher, ignore)
		}

	}
	if _, ok := ignore["cerbos.policy.v1.PrincipalRule.Action.effect"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(nil, uint64(m.Effect)))

	}
	if _, ok := ignore["cerbos.policy.v1.PrincipalRule.Action.name"]; !ok {
		_, _ = hasher.Write(protowire.AppendString(nil, m.Name))

	}
	if _, ok := ignore["cerbos.policy.v1.PrincipalRule.Action.output"]; !ok {
		if m.Output != nil {
			cerbos_policy_v1_Output_hashpb_sum(m.Output, hasher, ignore)
		}

	}
}

func cerbos_policy_v1_PrincipalRule_hashpb_sum(m *v1.PrincipalRule, hasher hash.Hash, ignore map[string]struct{}) {
	if _, ok := ignore["cerbos.policy.v1.PrincipalRule.resource"]; !ok {
		_, _ = hasher.Write(protowire.AppendString(nil, m.Resource))

	}
	if _, ok := ignore["cerbos.policy.v1.PrincipalRule.actions"]; !ok {
		if len(m.Actions) > 0 {
			for _, v := range m.Actions {
				if v != nil {
					cerbos_policy_v1_PrincipalRule_Action_hashpb_sum(v, hasher, ignore)
				}

			}
		}
	}
}

func cerbos_policy_v1_ResourcePolicy_hashpb_sum(m *v1.ResourcePolicy, hasher hash.Hash, ignore map[string]struct{}) {
	if _, ok := ignore["cerbos.policy.v1.ResourcePolicy.resource"]; !ok {
		_, _ = hasher.Write(protowire.AppendString(nil, m.Resource))

	}
	if _, ok := ignore["cerbos.policy.v1.ResourcePolicy.version"]; !ok {
		_, _ = hasher.Write(protowire.AppendString(nil, m.Version))

	}
	if _, ok := ignore["cerbos.policy.v1.ResourcePolicy.import_derived_roles"]; !ok {
		if len(m.ImportDerivedRoles) > 0 {
			for _, v := range m.ImportDerivedRoles {
				_, _ = hasher.Write(protowire.AppendString(nil, v))

			}
		}
	}
	if _, ok := ignore["cerbos.policy.v1.ResourcePolicy.rules"]; !ok {
		if len(m.Rules) > 0 {
			for _, v := range m.Rules {
				if v != nil {
					cerbos_policy_v1_ResourceRule_hashpb_sum(v, hasher, ignore)
				}

			}
		}
	}
	if _, ok := ignore["cerbos.policy.v1.ResourcePolicy.scope"]; !ok {
		_, _ = hasher.Write(protowire.AppendString(nil, m.Scope))

	}
	if _, ok := ignore["cerbos.policy.v1.ResourcePolicy.schemas"]; !ok {
		if m.Schemas != nil {
			cerbos_policy_v1_Schemas_hashpb_sum(m.Schemas, hasher, ignore)
		}

	}
	if _, ok := ignore["cerbos.policy.v1.ResourcePolicy.variables"]; !ok {
		if m.Variables != nil {
			cerbos_policy_v1_Variables_hashpb_sum(m.Variables, hasher, ignore)
		}

	}
}

func cerbos_policy_v1_ResourceRule_hashpb_sum(m *v1.ResourceRule, hasher hash.Hash, ignore map[string]struct{}) {
	if _, ok := ignore["cerbos.policy.v1.ResourceRule.actions"]; !ok {
		if len(m.Actions) > 0 {
			for _, v := range m.Actions {
				_, _ = hasher.Write(protowire.AppendString(nil, v))

			}
		}
	}
	if _, ok := ignore["cerbos.policy.v1.ResourceRule.derived_roles"]; !ok {
		if len(m.DerivedRoles) > 0 {
			for _, v := range m.DerivedRoles {
				_, _ = hasher.Write(protowire.AppendString(nil, v))

			}
		}
	}
	if _, ok := ignore["cerbos.policy.v1.ResourceRule.roles"]; !ok {
		if len(m.Roles) > 0 {
			for _, v := range m.Roles {
				_, _ = hasher.Write(protowire.AppendString(nil, v))

			}
		}
	}
	if _, ok := ignore["cerbos.policy.v1.ResourceRule.condition"]; !ok {
		if m.Condition != nil {
			cerbos_policy_v1_Condition_hashpb_sum(m.Condition, hasher, ignore)
		}

	}
	if _, ok := ignore["cerbos.policy.v1.ResourceRule.effect"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(nil, uint64(m.Effect)))

	}
	if _, ok := ignore["cerbos.policy.v1.ResourceRule.name"]; !ok {
		_, _ = hasher.Write(protowire.AppendString(nil, m.Name))

	}
	if _, ok := ignore["cerbos.policy.v1.ResourceRule.output"]; !ok {
		if m.Output != nil {
			cerbos_policy_v1_Output_hashpb_sum(m.Output, hasher, ignore)
		}

	}
}

func cerbos_policy_v1_RoleDef_hashpb_sum(m *v1.RoleDef, hasher hash.Hash, ignore map[string]struct{}) {
	if _, ok := ignore["cerbos.policy.v1.RoleDef.name"]; !ok {
		_, _ = hasher.Write(protowire.AppendString(nil, m.Name))

	}
	if _, ok := ignore["cerbos.policy.v1.RoleDef.parent_roles"]; !ok {
		if len(m.ParentRoles) > 0 {
			for _, v := range m.ParentRoles {
				_, _ = hasher.Write(protowire.AppendString(nil, v))

			}
		}
	}
	if _, ok := ignore["cerbos.policy.v1.RoleDef.condition"]; !ok {
		if m.Condition != nil {
			cerbos_policy_v1_Condition_hashpb_sum(m.Condition, hasher, ignore)
		}

	}
}

func cerbos_policy_v1_Schemas_IgnoreWhen_hashpb_sum(m *v1.Schemas_IgnoreWhen, hasher hash.Hash, ignore map[string]struct{}) {
	if _, ok := ignore["cerbos.policy.v1.Schemas.IgnoreWhen.actions"]; !ok {
		if len(m.Actions) > 0 {
			for _, v := range m.Actions {
				_, _ = hasher.Write(protowire.AppendString(nil, v))

			}
		}
	}
}

func cerbos_policy_v1_Schemas_Schema_hashpb_sum(m *v1.Schemas_Schema, hasher hash.Hash, ignore map[string]struct{}) {
	if _, ok := ignore["cerbos.policy.v1.Schemas.Schema.ref"]; !ok {
		_, _ = hasher.Write(protowire.AppendString(nil, m.Ref))

	}
	if _, ok := ignore["cerbos.policy.v1.Schemas.Schema.ignore_when"]; !ok {
		if m.IgnoreWhen != nil {
			cerbos_policy_v1_Schemas_IgnoreWhen_hashpb_sum(m.IgnoreWhen, hasher, ignore)
		}

	}
}

func cerbos_policy_v1_Schemas_hashpb_sum(m *v1.Schemas, hasher hash.Hash, ignore map[string]struct{}) {
	if _, ok := ignore["cerbos.policy.v1.Schemas.principal_schema"]; !ok {
		if m.PrincipalSchema != nil {
			cerbos_policy_v1_Schemas_Schema_hashpb_sum(m.PrincipalSchema, hasher, ignore)
		}

	}
	if _, ok := ignore["cerbos.policy.v1.Schemas.resource_schema"]; !ok {
		if m.ResourceSchema != nil {
			cerbos_policy_v1_Schemas_Schema_hashpb_sum(m.ResourceSchema, hasher, ignore)
		}

	}
}

func cerbos_policy_v1_SourceAttributes_hashpb_sum(m *v1.SourceAttributes, hasher hash.Hash, ignore map[string]struct{}) {
	if _, ok := ignore["cerbos.policy.v1.SourceAttributes.attributes"]; !ok {
		if len(m.Attributes) > 0 {
			keys := make([]string, len(m.Attributes))
			i := 0
			for k := range m.Attributes {
				keys[i] = k
				i++
			}

			sort.Slice(keys, func(i, j int) bool { return keys[i] < keys[j] })

			for _, k := range keys {
				if m.Attributes[k] != nil {
					google_protobuf_Value_hashpb_sum(m.Attributes[k], hasher, ignore)
				}

			}
		}
	}
}

func cerbos_policy_v1_Variables_hashpb_sum(m *v1.Variables, hasher hash.Hash, ignore map[string]struct{}) {
	if _, ok := ignore["cerbos.policy.v1.Variables.import"]; !ok {
		if len(m.Import) > 0 {
			for _, v := range m.Import {
				_, _ = hasher.Write(protowire.AppendString(nil, v))

			}
		}
	}
	if _, ok := ignore["cerbos.policy.v1.Variables.local"]; !ok {
		if len(m.Local) > 0 {
			keys := make([]string, len(m.Local))
			i := 0
			for k := range m.Local {
				keys[i] = k
				i++
			}

			sort.Slice(keys, func(i, j int) bool { return keys[i] < keys[j] })

			for _, k := range keys {
				_, _ = hasher.Write(protowire.AppendString(nil, m.Local[k]))

			}
		}
	}
}

func cerbos_source_v1_Error_hashpb_sum(m *Error, hasher hash.Hash, ignore map[string]struct{}) {
	if _, ok := ignore["cerbos.source.v1.Error.kind"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(nil, uint64(m.Kind)))

	}
	if _, ok := ignore["cerbos.source.v1.Error.position"]; !ok {
		if m.Position != nil {
			cerbos_source_v1_Position_hashpb_sum(m.Position, hasher, ignore)
		}

	}
	if _, ok := ignore["cerbos.source.v1.Error.message"]; !ok {
		_, _ = hasher.Write(protowire.AppendString(nil, m.Message))

	}
	if _, ok := ignore["cerbos.source.v1.Error.context"]; !ok {
		_, _ = hasher.Write(protowire.AppendString(nil, m.Context))

	}
}

func cerbos_source_v1_ParsedFile_hashpb_sum(m *ParsedFile, hasher hash.Hash, ignore map[string]struct{}) {
	if _, ok := ignore["cerbos.source.v1.ParsedFile.path"]; !ok {
		_, _ = hasher.Write(protowire.AppendString(nil, m.Path))

	}
	if _, ok := ignore["cerbos.source.v1.ParsedFile.policies"]; !ok {
		if len(m.Policies) > 0 {
			for _, v := range m.Policies {
				if v != nil {
					cerbos_source_v1_ParsedPolicy_hashpb_sum(v, hasher, ignore)
				}

			}
		}
	}
}

func cerbos_source_v1_ParsedPolicy_hashpb_sum(m *ParsedPolicy, hasher hash.Hash, ignore map[string]struct{}) {
	if _, ok := ignore["cerbos.source.v1.ParsedPolicy.policy"]; !ok {
		if m.Policy != nil {
			cerbos_policy_v1_Policy_hashpb_sum(m.Policy, hasher, ignore)
		}

	}
	if _, ok := ignore["cerbos.source.v1.ParsedPolicy.source_context"]; !ok {
		if m.SourceContext != nil {
			cerbos_source_v1_SourceContext_hashpb_sum(m.SourceContext, hasher, ignore)
		}

	}
}

func cerbos_source_v1_Position_hashpb_sum(m *Position, hasher hash.Hash, ignore map[string]struct{}) {
	if _, ok := ignore["cerbos.source.v1.Position.line"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(nil, uint64(m.Line)))

	}
	if _, ok := ignore["cerbos.source.v1.Position.column"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(nil, uint64(m.Column)))

	}
	if _, ok := ignore["cerbos.source.v1.Position.path"]; !ok {
		_, _ = hasher.Write(protowire.AppendString(nil, m.Path))

	}
}

func cerbos_source_v1_SourceContext_hashpb_sum(m *SourceContext, hasher hash.Hash, ignore map[string]struct{}) {
	if _, ok := ignore["cerbos.source.v1.SourceContext.field_positions"]; !ok {
		if len(m.FieldPositions) > 0 {
			keys := make([]string, len(m.FieldPositions))
			i := 0
			for k := range m.FieldPositions {
				keys[i] = k
				i++
			}

			sort.Slice(keys, func(i, j int) bool { return keys[i] < keys[j] })

			for _, k := range keys {
				if m.FieldPositions[k] != nil {
					cerbos_source_v1_Position_hashpb_sum(m.FieldPositions[k], hasher, ignore)
				}

			}
		}
	}
	if _, ok := ignore["cerbos.source.v1.SourceContext.errors"]; !ok {
		if len(m.Errors) > 0 {
			for _, v := range m.Errors {
				if v != nil {
					cerbos_source_v1_Error_hashpb_sum(v, hasher, ignore)
				}

			}
		}
	}
}

func google_protobuf_ListValue_hashpb_sum(m *structpb.ListValue, hasher hash.Hash, ignore map[string]struct{}) {
	if _, ok := ignore["google.protobuf.ListValue.values"]; !ok {
		if len(m.Values) > 0 {
			for _, v := range m.Values {
				if v != nil {
					google_protobuf_Value_hashpb_sum(v, hasher, ignore)
				}

			}
		}
	}
}

func google_protobuf_Struct_hashpb_sum(m *structpb.Struct, hasher hash.Hash, ignore map[string]struct{}) {
	if _, ok := ignore["google.protobuf.Struct.fields"]; !ok {
		if len(m.Fields) > 0 {
			keys := make([]string, len(m.Fields))
			i := 0
			for k := range m.Fields {
				keys[i] = k
				i++
			}

			sort.Slice(keys, func(i, j int) bool { return keys[i] < keys[j] })

			for _, k := range keys {
				if m.Fields[k] != nil {
					google_protobuf_Value_hashpb_sum(m.Fields[k], hasher, ignore)
				}

			}
		}
	}
}

func google_protobuf_UInt64Value_hashpb_sum(m *wrapperspb.UInt64Value, hasher hash.Hash, ignore map[string]struct{}) {
	if _, ok := ignore["google.protobuf.UInt64Value.value"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(nil, m.Value))

	}
}

func google_protobuf_Value_hashpb_sum(m *structpb.Value, hasher hash.Hash, ignore map[string]struct{}) {
	if m.Kind != nil {
		if _, ok := ignore["google.protobuf.Value.kind"]; !ok {
			switch t := m.Kind.(type) {
			case *structpb.Value_NullValue:
				_, _ = hasher.Write(protowire.AppendVarint(nil, uint64(t.NullValue)))

			case *structpb.Value_NumberValue:
				_, _ = hasher.Write(protowire.AppendFixed64(nil, math.Float64bits(t.NumberValue)))

			case *structpb.Value_StringValue:
				_, _ = hasher.Write(protowire.AppendString(nil, t.StringValue))

			case *structpb.Value_BoolValue:
				_, _ = hasher.Write(protowire.AppendVarint(nil, protowire.EncodeBool(t.BoolValue)))

			case *structpb.Value_StructValue:
				if t.StructValue != nil {
					google_protobuf_Struct_hashpb_sum(t.StructValue, hasher, ignore)
				}

			case *structpb.Value_ListValue:
				if t.ListValue != nil {
					google_protobuf_ListValue_hashpb_sum(t.ListValue, hasher, ignore)
				}

			}
		}
	}
}
