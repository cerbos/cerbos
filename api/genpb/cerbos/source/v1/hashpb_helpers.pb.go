// Code generated by protoc-gen-go-hashpb. Do not edit.
// protoc-gen-go-hashpb v0.3.1

package sourcev1

import (
	protowire "google.golang.org/protobuf/encoding/protowire"
	hash "hash"
	sort "sort"
)

func cerbos_source_v1_Error_hashpb_sum(m *Error, hasher hash.Hash, ignore map[string]struct{}) {
	if _, ok := ignore["cerbos.source.v1.Error.kind"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(nil, uint64(m.GetKind())))

	}
	if _, ok := ignore["cerbos.source.v1.Error.position"]; !ok {
		if m.GetPosition() != nil {
			cerbos_source_v1_Position_hashpb_sum(m.GetPosition(), hasher, ignore)
		}

	}
	if _, ok := ignore["cerbos.source.v1.Error.message"]; !ok {
		_, _ = hasher.Write(protowire.AppendString(nil, m.GetMessage()))

	}
	if _, ok := ignore["cerbos.source.v1.Error.context"]; !ok {
		_, _ = hasher.Write(protowire.AppendString(nil, m.GetContext()))

	}
}

func cerbos_source_v1_Position_hashpb_sum(m *Position, hasher hash.Hash, ignore map[string]struct{}) {
	if _, ok := ignore["cerbos.source.v1.Position.line"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(nil, uint64(m.GetLine())))

	}
	if _, ok := ignore["cerbos.source.v1.Position.column"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(nil, uint64(m.GetColumn())))

	}
	if _, ok := ignore["cerbos.source.v1.Position.path"]; !ok {
		_, _ = hasher.Write(protowire.AppendString(nil, m.GetPath()))

	}
}

func cerbos_source_v1_SourceContext_hashpb_sum(m *SourceContext, hasher hash.Hash, ignore map[string]struct{}) {
	if _, ok := ignore["cerbos.source.v1.SourceContext.start_position"]; !ok {
		if m.GetStartPosition() != nil {
			cerbos_source_v1_StartPosition_hashpb_sum(m.GetStartPosition(), hasher, ignore)
		}

	}
	if _, ok := ignore["cerbos.source.v1.SourceContext.field_positions"]; !ok {
		if len(m.FieldPositions) > 0 {
			keys := make([]string, len(m.FieldPositions))
			i := 0
			for k := range m.FieldPositions {
				keys[i] = k
				i++
			}

			sort.Slice(keys, func(i, j int) bool { return keys[i] < keys[j] })

			for _, k := range keys {
				if m.FieldPositions[k] != nil {
					cerbos_source_v1_Position_hashpb_sum(m.FieldPositions[k], hasher, ignore)
				}

			}
		}
	}
	if _, ok := ignore["cerbos.source.v1.SourceContext.errors"]; !ok {
		if len(m.Errors) > 0 {
			for _, v := range m.Errors {
				if v != nil {
					cerbos_source_v1_Error_hashpb_sum(v, hasher, ignore)
				}

			}
		}
	}
}

func cerbos_source_v1_StartPosition_hashpb_sum(m *StartPosition, hasher hash.Hash, ignore map[string]struct{}) {
	if _, ok := ignore["cerbos.source.v1.StartPosition.line"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(nil, uint64(m.GetLine())))

	}
	if _, ok := ignore["cerbos.source.v1.StartPosition.column"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(nil, uint64(m.GetColumn())))

	}
	if _, ok := ignore["cerbos.source.v1.StartPosition.offset"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(nil, uint64(m.GetOffset())))

	}
}
