// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: cerbos/policy/v1/policy.proto

package policyv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	effectv1 "github.com/cerbos/cerbos/api/genpb/cerbos/effect/v1"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = effectv1.Effect(0)
)

// Validate checks the field values on Policy with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Policy) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Policy with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PolicyMultiError, or nil if none found.
func (m *Policy) ValidateAll() error {
	return m.validate(true)
}

func (m *Policy) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetApiVersion() != "api.cerbos.dev/v1" {
		err := PolicyValidationError{
			field:  "ApiVersion",
			reason: "value must equal api.cerbos.dev/v1",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Disabled

	// no validation rules for Description

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PolicyValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PolicyValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PolicyValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Variables

	switch m.PolicyType.(type) {

	case *Policy_ResourcePolicy:

		if all {
			switch v := interface{}(m.GetResourcePolicy()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PolicyValidationError{
						field:  "ResourcePolicy",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PolicyValidationError{
						field:  "ResourcePolicy",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResourcePolicy()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PolicyValidationError{
					field:  "ResourcePolicy",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Policy_PrincipalPolicy:

		if all {
			switch v := interface{}(m.GetPrincipalPolicy()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PolicyValidationError{
						field:  "PrincipalPolicy",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PolicyValidationError{
						field:  "PrincipalPolicy",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPrincipalPolicy()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PolicyValidationError{
					field:  "PrincipalPolicy",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Policy_DerivedRoles:

		if all {
			switch v := interface{}(m.GetDerivedRoles()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PolicyValidationError{
						field:  "DerivedRoles",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PolicyValidationError{
						field:  "DerivedRoles",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDerivedRoles()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PolicyValidationError{
					field:  "DerivedRoles",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		err := PolicyValidationError{
			field:  "PolicyType",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if len(errors) > 0 {
		return PolicyMultiError(errors)
	}

	return nil
}

// PolicyMultiError is an error wrapping multiple validation errors returned by
// Policy.ValidateAll() if the designated constraints aren't met.
type PolicyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PolicyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PolicyMultiError) AllErrors() []error { return m }

// PolicyValidationError is the validation error returned by Policy.Validate if
// the designated constraints aren't met.
type PolicyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PolicyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PolicyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PolicyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PolicyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PolicyValidationError) ErrorName() string { return "PolicyValidationError" }

// Error satisfies the builtin error interface
func (e PolicyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPolicy.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PolicyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PolicyValidationError{}

// Validate checks the field values on Metadata with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Metadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Metadata with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MetadataMultiError, or nil
// if none found.
func (m *Metadata) ValidateAll() error {
	return m.validate(true)
}

func (m *Metadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SourceFile

	// no validation rules for Annotations

	if all {
		switch v := interface{}(m.GetHash()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetadataValidationError{
					field:  "Hash",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetadataValidationError{
					field:  "Hash",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHash()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetadataValidationError{
				field:  "Hash",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for StoreIdentifer

	if len(errors) > 0 {
		return MetadataMultiError(errors)
	}

	return nil
}

// MetadataMultiError is an error wrapping multiple validation errors returned
// by Metadata.ValidateAll() if the designated constraints aren't met.
type MetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetadataMultiError) AllErrors() []error { return m }

// MetadataValidationError is the validation error returned by
// Metadata.Validate if the designated constraints aren't met.
type MetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetadataValidationError) ErrorName() string { return "MetadataValidationError" }

// Error satisfies the builtin error interface
func (e MetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetadataValidationError{}

// Validate checks the field values on ResourcePolicy with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ResourcePolicy) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResourcePolicy with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResourcePolicyMultiError,
// or nil if none found.
func (m *ResourcePolicy) ValidateAll() error {
	return m.validate(true)
}

func (m *ResourcePolicy) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetResource()) < 1 {
		err := ResourcePolicyValidationError{
			field:  "Resource",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ResourcePolicy_Resource_Pattern.MatchString(m.GetResource()) {
		err := ResourcePolicyValidationError{
			field:  "Resource",
			reason: "value does not match regex pattern \"^[[:alpha:]][[:word:]\\\\@\\\\.\\\\-/]*(\\\\:[[:alpha:]][[:word:]\\\\@\\\\.\\\\-/]*)*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ResourcePolicy_Version_Pattern.MatchString(m.GetVersion()) {
		err := ResourcePolicyValidationError{
			field:  "Version",
			reason: "value does not match regex pattern \"^[[:word:]]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_ResourcePolicy_ImportDerivedRoles_Unique := make(map[string]struct{}, len(m.GetImportDerivedRoles()))

	for idx, item := range m.GetImportDerivedRoles() {
		_, _ = idx, item

		if _, exists := _ResourcePolicy_ImportDerivedRoles_Unique[item]; exists {
			err := ResourcePolicyValidationError{
				field:  fmt.Sprintf("ImportDerivedRoles[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_ResourcePolicy_ImportDerivedRoles_Unique[item] = struct{}{}
		}

		if !_ResourcePolicy_ImportDerivedRoles_Pattern.MatchString(item) {
			err := ResourcePolicyValidationError{
				field:  fmt.Sprintf("ImportDerivedRoles[%v]", idx),
				reason: "value does not match regex pattern \"^[[:word:]\\\\-\\\\.]+$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	for idx, item := range m.GetRules() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourcePolicyValidationError{
						field:  fmt.Sprintf("Rules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourcePolicyValidationError{
						field:  fmt.Sprintf("Rules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourcePolicyValidationError{
					field:  fmt.Sprintf("Rules[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if !_ResourcePolicy_Scope_Pattern.MatchString(m.GetScope()) {
		err := ResourcePolicyValidationError{
			field:  "Scope",
			reason: "value does not match regex pattern \"^([[:alpha:]][[:word:]\\\\-]+(\\\\.[[:alpha:]][[:word:]\\\\-]*)*)*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSchemas()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourcePolicyValidationError{
					field:  "Schemas",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourcePolicyValidationError{
					field:  "Schemas",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSchemas()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourcePolicyValidationError{
				field:  "Schemas",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ResourcePolicyMultiError(errors)
	}

	return nil
}

// ResourcePolicyMultiError is an error wrapping multiple validation errors
// returned by ResourcePolicy.ValidateAll() if the designated constraints
// aren't met.
type ResourcePolicyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourcePolicyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourcePolicyMultiError) AllErrors() []error { return m }

// ResourcePolicyValidationError is the validation error returned by
// ResourcePolicy.Validate if the designated constraints aren't met.
type ResourcePolicyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourcePolicyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourcePolicyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourcePolicyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourcePolicyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourcePolicyValidationError) ErrorName() string { return "ResourcePolicyValidationError" }

// Error satisfies the builtin error interface
func (e ResourcePolicyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResourcePolicy.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourcePolicyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourcePolicyValidationError{}

var _ResourcePolicy_Resource_Pattern = regexp.MustCompile("^[[:alpha:]][[:word:]\\@\\.\\-/]*(\\:[[:alpha:]][[:word:]\\@\\.\\-/]*)*$")

var _ResourcePolicy_Version_Pattern = regexp.MustCompile("^[[:word:]]+$")

var _ResourcePolicy_ImportDerivedRoles_Pattern = regexp.MustCompile("^[[:word:]\\-\\.]+$")

var _ResourcePolicy_Scope_Pattern = regexp.MustCompile("^([[:alpha:]][[:word:]\\-]+(\\.[[:alpha:]][[:word:]\\-]*)*)*$")

// Validate checks the field values on ResourceRule with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ResourceRule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResourceRule with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResourceRuleMultiError, or
// nil if none found.
func (m *ResourceRule) ValidateAll() error {
	return m.validate(true)
}

func (m *ResourceRule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetActions()) < 1 {
		err := ResourceRuleValidationError{
			field:  "Actions",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_ResourceRule_Actions_Unique := make(map[string]struct{}, len(m.GetActions()))

	for idx, item := range m.GetActions() {
		_, _ = idx, item

		if _, exists := _ResourceRule_Actions_Unique[item]; exists {
			err := ResourceRuleValidationError{
				field:  fmt.Sprintf("Actions[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_ResourceRule_Actions_Unique[item] = struct{}{}
		}

		if utf8.RuneCountInString(item) < 1 {
			err := ResourceRuleValidationError{
				field:  fmt.Sprintf("Actions[%v]", idx),
				reason: "value length must be at least 1 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	_ResourceRule_DerivedRoles_Unique := make(map[string]struct{}, len(m.GetDerivedRoles()))

	for idx, item := range m.GetDerivedRoles() {
		_, _ = idx, item

		if _, exists := _ResourceRule_DerivedRoles_Unique[item]; exists {
			err := ResourceRuleValidationError{
				field:  fmt.Sprintf("DerivedRoles[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_ResourceRule_DerivedRoles_Unique[item] = struct{}{}
		}

		if !_ResourceRule_DerivedRoles_Pattern.MatchString(item) {
			err := ResourceRuleValidationError{
				field:  fmt.Sprintf("DerivedRoles[%v]", idx),
				reason: "value does not match regex pattern \"^[[:word:]\\\\-\\\\.]+$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	_ResourceRule_Roles_Unique := make(map[string]struct{}, len(m.GetRoles()))

	for idx, item := range m.GetRoles() {
		_, _ = idx, item

		if _, exists := _ResourceRule_Roles_Unique[item]; exists {
			err := ResourceRuleValidationError{
				field:  fmt.Sprintf("Roles[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_ResourceRule_Roles_Unique[item] = struct{}{}
		}

		if !_ResourceRule_Roles_Pattern.MatchString(item) {
			err := ResourceRuleValidationError{
				field:  fmt.Sprintf("Roles[%v]", idx),
				reason: "value does not match regex pattern \"^[[:word:]\\\\-\\\\.]+$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetCondition()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceRuleValidationError{
					field:  "Condition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceRuleValidationError{
					field:  "Condition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCondition()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceRuleValidationError{
				field:  "Condition",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if _, ok := _ResourceRule_Effect_InLookup[m.GetEffect()]; !ok {
		err := ResourceRuleValidationError{
			field:  "Effect",
			reason: "value must be in list [1 2]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ResourceRule_Name_Pattern.MatchString(m.GetName()) {
		err := ResourceRuleValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^([[:alpha:]][[:word:]\\\\@\\\\.\\\\-]*)*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ResourceRuleMultiError(errors)
	}

	return nil
}

// ResourceRuleMultiError is an error wrapping multiple validation errors
// returned by ResourceRule.ValidateAll() if the designated constraints aren't met.
type ResourceRuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourceRuleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourceRuleMultiError) AllErrors() []error { return m }

// ResourceRuleValidationError is the validation error returned by
// ResourceRule.Validate if the designated constraints aren't met.
type ResourceRuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourceRuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourceRuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourceRuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourceRuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourceRuleValidationError) ErrorName() string { return "ResourceRuleValidationError" }

// Error satisfies the builtin error interface
func (e ResourceRuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResourceRule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourceRuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourceRuleValidationError{}

var _ResourceRule_DerivedRoles_Pattern = regexp.MustCompile("^[[:word:]\\-\\.]+$")

var _ResourceRule_Roles_Pattern = regexp.MustCompile("^[[:word:]\\-\\.]+$")

var _ResourceRule_Effect_InLookup = map[effectv1.Effect]struct{}{
	1: {},
	2: {},
}

var _ResourceRule_Name_Pattern = regexp.MustCompile("^([[:alpha:]][[:word:]\\@\\.\\-]*)*$")

// Validate checks the field values on PrincipalPolicy with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PrincipalPolicy) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PrincipalPolicy with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PrincipalPolicyMultiError, or nil if none found.
func (m *PrincipalPolicy) ValidateAll() error {
	return m.validate(true)
}

func (m *PrincipalPolicy) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetPrincipal()) < 1 {
		err := PrincipalPolicyValidationError{
			field:  "Principal",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_PrincipalPolicy_Principal_Pattern.MatchString(m.GetPrincipal()) {
		err := PrincipalPolicyValidationError{
			field:  "Principal",
			reason: "value does not match regex pattern \"^[[:alpha:]][[:word:]\\\\@\\\\.\\\\-]*(\\\\:[[:alpha:]][[:word:]\\\\@\\\\.\\\\-]*)*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_PrincipalPolicy_Version_Pattern.MatchString(m.GetVersion()) {
		err := PrincipalPolicyValidationError{
			field:  "Version",
			reason: "value does not match regex pattern \"^[[:word:]]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetRules() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PrincipalPolicyValidationError{
						field:  fmt.Sprintf("Rules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PrincipalPolicyValidationError{
						field:  fmt.Sprintf("Rules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PrincipalPolicyValidationError{
					field:  fmt.Sprintf("Rules[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if !_PrincipalPolicy_Scope_Pattern.MatchString(m.GetScope()) {
		err := PrincipalPolicyValidationError{
			field:  "Scope",
			reason: "value does not match regex pattern \"^([[:alpha:]][[:word:]\\\\-]+(\\\\.[[:alpha:]][[:word:]\\\\-]*)*)*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return PrincipalPolicyMultiError(errors)
	}

	return nil
}

// PrincipalPolicyMultiError is an error wrapping multiple validation errors
// returned by PrincipalPolicy.ValidateAll() if the designated constraints
// aren't met.
type PrincipalPolicyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PrincipalPolicyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PrincipalPolicyMultiError) AllErrors() []error { return m }

// PrincipalPolicyValidationError is the validation error returned by
// PrincipalPolicy.Validate if the designated constraints aren't met.
type PrincipalPolicyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PrincipalPolicyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PrincipalPolicyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PrincipalPolicyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PrincipalPolicyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PrincipalPolicyValidationError) ErrorName() string { return "PrincipalPolicyValidationError" }

// Error satisfies the builtin error interface
func (e PrincipalPolicyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPrincipalPolicy.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PrincipalPolicyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PrincipalPolicyValidationError{}

var _PrincipalPolicy_Principal_Pattern = regexp.MustCompile("^[[:alpha:]][[:word:]\\@\\.\\-]*(\\:[[:alpha:]][[:word:]\\@\\.\\-]*)*$")

var _PrincipalPolicy_Version_Pattern = regexp.MustCompile("^[[:word:]]+$")

var _PrincipalPolicy_Scope_Pattern = regexp.MustCompile("^([[:alpha:]][[:word:]\\-]+(\\.[[:alpha:]][[:word:]\\-]*)*)*$")

// Validate checks the field values on PrincipalRule with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PrincipalRule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PrincipalRule with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PrincipalRuleMultiError, or
// nil if none found.
func (m *PrincipalRule) ValidateAll() error {
	return m.validate(true)
}

func (m *PrincipalRule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetResource()) < 1 {
		err := PrincipalRuleValidationError{
			field:  "Resource",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_PrincipalRule_Resource_Pattern.MatchString(m.GetResource()) {
		err := PrincipalRuleValidationError{
			field:  "Resource",
			reason: "value does not match regex pattern \"^[[:alpha:]][[:word:]\\\\@\\\\.\\\\-/]*(\\\\:[[:alpha:]][[:word:]\\\\@\\\\.\\\\-/]*)*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetActions()) < 1 {
		err := PrincipalRuleValidationError{
			field:  "Actions",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetActions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PrincipalRuleValidationError{
						field:  fmt.Sprintf("Actions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PrincipalRuleValidationError{
						field:  fmt.Sprintf("Actions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PrincipalRuleValidationError{
					field:  fmt.Sprintf("Actions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PrincipalRuleMultiError(errors)
	}

	return nil
}

// PrincipalRuleMultiError is an error wrapping multiple validation errors
// returned by PrincipalRule.ValidateAll() if the designated constraints
// aren't met.
type PrincipalRuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PrincipalRuleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PrincipalRuleMultiError) AllErrors() []error { return m }

// PrincipalRuleValidationError is the validation error returned by
// PrincipalRule.Validate if the designated constraints aren't met.
type PrincipalRuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PrincipalRuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PrincipalRuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PrincipalRuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PrincipalRuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PrincipalRuleValidationError) ErrorName() string { return "PrincipalRuleValidationError" }

// Error satisfies the builtin error interface
func (e PrincipalRuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPrincipalRule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PrincipalRuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PrincipalRuleValidationError{}

var _PrincipalRule_Resource_Pattern = regexp.MustCompile("^[[:alpha:]][[:word:]\\@\\.\\-/]*(\\:[[:alpha:]][[:word:]\\@\\.\\-/]*)*$")

// Validate checks the field values on DerivedRoles with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DerivedRoles) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DerivedRoles with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DerivedRolesMultiError, or
// nil if none found.
func (m *DerivedRoles) ValidateAll() error {
	return m.validate(true)
}

func (m *DerivedRoles) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := DerivedRolesValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DerivedRoles_Name_Pattern.MatchString(m.GetName()) {
		err := DerivedRolesValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[[:word:]\\\\-\\\\.]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetDefinitions()) < 1 {
		err := DerivedRolesValidationError{
			field:  "Definitions",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetDefinitions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DerivedRolesValidationError{
						field:  fmt.Sprintf("Definitions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DerivedRolesValidationError{
						field:  fmt.Sprintf("Definitions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DerivedRolesValidationError{
					field:  fmt.Sprintf("Definitions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DerivedRolesMultiError(errors)
	}

	return nil
}

// DerivedRolesMultiError is an error wrapping multiple validation errors
// returned by DerivedRoles.ValidateAll() if the designated constraints aren't met.
type DerivedRolesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DerivedRolesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DerivedRolesMultiError) AllErrors() []error { return m }

// DerivedRolesValidationError is the validation error returned by
// DerivedRoles.Validate if the designated constraints aren't met.
type DerivedRolesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DerivedRolesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DerivedRolesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DerivedRolesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DerivedRolesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DerivedRolesValidationError) ErrorName() string { return "DerivedRolesValidationError" }

// Error satisfies the builtin error interface
func (e DerivedRolesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDerivedRoles.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DerivedRolesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DerivedRolesValidationError{}

var _DerivedRoles_Name_Pattern = regexp.MustCompile("^[[:word:]\\-\\.]+$")

// Validate checks the field values on RoleDef with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RoleDef) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RoleDef with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RoleDefMultiError, or nil if none found.
func (m *RoleDef) ValidateAll() error {
	return m.validate(true)
}

func (m *RoleDef) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_RoleDef_Name_Pattern.MatchString(m.GetName()) {
		err := RoleDefValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[[:word:]\\\\-\\\\.]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetParentRoles()) < 1 {
		err := RoleDefValidationError{
			field:  "ParentRoles",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_RoleDef_ParentRoles_Unique := make(map[string]struct{}, len(m.GetParentRoles()))

	for idx, item := range m.GetParentRoles() {
		_, _ = idx, item

		if _, exists := _RoleDef_ParentRoles_Unique[item]; exists {
			err := RoleDefValidationError{
				field:  fmt.Sprintf("ParentRoles[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_RoleDef_ParentRoles_Unique[item] = struct{}{}
		}

		if !_RoleDef_ParentRoles_Pattern.MatchString(item) {
			err := RoleDefValidationError{
				field:  fmt.Sprintf("ParentRoles[%v]", idx),
				reason: "value does not match regex pattern \"^[[:word:]\\\\-\\\\.]+$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetCondition()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RoleDefValidationError{
					field:  "Condition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RoleDefValidationError{
					field:  "Condition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCondition()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RoleDefValidationError{
				field:  "Condition",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RoleDefMultiError(errors)
	}

	return nil
}

// RoleDefMultiError is an error wrapping multiple validation errors returned
// by RoleDef.ValidateAll() if the designated constraints aren't met.
type RoleDefMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RoleDefMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RoleDefMultiError) AllErrors() []error { return m }

// RoleDefValidationError is the validation error returned by RoleDef.Validate
// if the designated constraints aren't met.
type RoleDefValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RoleDefValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RoleDefValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RoleDefValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RoleDefValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RoleDefValidationError) ErrorName() string { return "RoleDefValidationError" }

// Error satisfies the builtin error interface
func (e RoleDefValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRoleDef.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RoleDefValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RoleDefValidationError{}

var _RoleDef_Name_Pattern = regexp.MustCompile("^[[:word:]\\-\\.]+$")

var _RoleDef_ParentRoles_Pattern = regexp.MustCompile("^[[:word:]\\-\\.]+$")

// Validate checks the field values on Condition with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Condition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Condition with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConditionMultiError, or nil
// if none found.
func (m *Condition) ValidateAll() error {
	return m.validate(true)
}

func (m *Condition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.Condition.(type) {

	case *Condition_Match:

		if all {
			switch v := interface{}(m.GetMatch()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConditionValidationError{
						field:  "Match",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConditionValidationError{
						field:  "Match",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMatch()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConditionValidationError{
					field:  "Match",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Condition_Script:
		// no validation rules for Script

	default:
		err := ConditionValidationError{
			field:  "Condition",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if len(errors) > 0 {
		return ConditionMultiError(errors)
	}

	return nil
}

// ConditionMultiError is an error wrapping multiple validation errors returned
// by Condition.ValidateAll() if the designated constraints aren't met.
type ConditionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConditionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConditionMultiError) AllErrors() []error { return m }

// ConditionValidationError is the validation error returned by
// Condition.Validate if the designated constraints aren't met.
type ConditionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConditionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConditionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConditionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConditionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConditionValidationError) ErrorName() string { return "ConditionValidationError" }

// Error satisfies the builtin error interface
func (e ConditionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCondition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConditionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConditionValidationError{}

// Validate checks the field values on Match with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Match) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Match with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in MatchMultiError, or nil if none found.
func (m *Match) ValidateAll() error {
	return m.validate(true)
}

func (m *Match) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.Op.(type) {

	case *Match_All:

		if all {
			switch v := interface{}(m.GetAll()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MatchValidationError{
						field:  "All",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MatchValidationError{
						field:  "All",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAll()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MatchValidationError{
					field:  "All",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Match_Any:

		if all {
			switch v := interface{}(m.GetAny()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MatchValidationError{
						field:  "Any",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MatchValidationError{
						field:  "Any",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAny()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MatchValidationError{
					field:  "Any",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Match_None:

		if all {
			switch v := interface{}(m.GetNone()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MatchValidationError{
						field:  "None",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MatchValidationError{
						field:  "None",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNone()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MatchValidationError{
					field:  "None",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Match_Expr:
		// no validation rules for Expr

	default:
		err := MatchValidationError{
			field:  "Op",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if len(errors) > 0 {
		return MatchMultiError(errors)
	}

	return nil
}

// MatchMultiError is an error wrapping multiple validation errors returned by
// Match.ValidateAll() if the designated constraints aren't met.
type MatchMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MatchMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MatchMultiError) AllErrors() []error { return m }

// MatchValidationError is the validation error returned by Match.Validate if
// the designated constraints aren't met.
type MatchValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MatchValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MatchValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MatchValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MatchValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MatchValidationError) ErrorName() string { return "MatchValidationError" }

// Error satisfies the builtin error interface
func (e MatchValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMatch.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MatchValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MatchValidationError{}

// Validate checks the field values on Schemas with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Schemas) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Schemas with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SchemasMultiError, or nil if none found.
func (m *Schemas) ValidateAll() error {
	return m.validate(true)
}

func (m *Schemas) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPrincipalSchema()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SchemasValidationError{
					field:  "PrincipalSchema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SchemasValidationError{
					field:  "PrincipalSchema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrincipalSchema()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SchemasValidationError{
				field:  "PrincipalSchema",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetResourceSchema()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SchemasValidationError{
					field:  "ResourceSchema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SchemasValidationError{
					field:  "ResourceSchema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResourceSchema()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SchemasValidationError{
				field:  "ResourceSchema",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SchemasMultiError(errors)
	}

	return nil
}

// SchemasMultiError is an error wrapping multiple validation errors returned
// by Schemas.ValidateAll() if the designated constraints aren't met.
type SchemasMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SchemasMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SchemasMultiError) AllErrors() []error { return m }

// SchemasValidationError is the validation error returned by Schemas.Validate
// if the designated constraints aren't met.
type SchemasValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SchemasValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SchemasValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SchemasValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SchemasValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SchemasValidationError) ErrorName() string { return "SchemasValidationError" }

// Error satisfies the builtin error interface
func (e SchemasValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSchemas.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SchemasValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SchemasValidationError{}

// Validate checks the field values on TestFixture with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TestFixture) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestFixture with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TestFixtureMultiError, or
// nil if none found.
func (m *TestFixture) ValidateAll() error {
	return m.validate(true)
}

func (m *TestFixture) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return TestFixtureMultiError(errors)
	}

	return nil
}

// TestFixtureMultiError is an error wrapping multiple validation errors
// returned by TestFixture.ValidateAll() if the designated constraints aren't met.
type TestFixtureMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestFixtureMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestFixtureMultiError) AllErrors() []error { return m }

// TestFixtureValidationError is the validation error returned by
// TestFixture.Validate if the designated constraints aren't met.
type TestFixtureValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestFixtureValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestFixtureValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestFixtureValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestFixtureValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestFixtureValidationError) ErrorName() string { return "TestFixtureValidationError" }

// Error satisfies the builtin error interface
func (e TestFixtureValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestFixture.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestFixtureValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestFixtureValidationError{}

// Validate checks the field values on TestSuite with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TestSuite) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestSuite with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TestSuiteMultiError, or nil
// if none found.
func (m *TestSuite) ValidateAll() error {
	return m.validate(true)
}

func (m *TestSuite) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := TestSuiteValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Description

	// no validation rules for Skip

	// no validation rules for SkipReason

	if len(m.GetTests()) < 1 {
		err := TestSuiteValidationError{
			field:  "Tests",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetTests() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TestSuiteValidationError{
						field:  fmt.Sprintf("Tests[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TestSuiteValidationError{
						field:  fmt.Sprintf("Tests[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TestSuiteValidationError{
					field:  fmt.Sprintf("Tests[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	{
		sorted_keys := make([]string, len(m.GetPrincipals()))
		i := 0
		for key := range m.GetPrincipals() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetPrincipals()[key]
			_ = val

			// no validation rules for Principals[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, TestSuiteValidationError{
							field:  fmt.Sprintf("Principals[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, TestSuiteValidationError{
							field:  fmt.Sprintf("Principals[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return TestSuiteValidationError{
						field:  fmt.Sprintf("Principals[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	{
		sorted_keys := make([]string, len(m.GetResources()))
		i := 0
		for key := range m.GetResources() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetResources()[key]
			_ = val

			// no validation rules for Resources[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, TestSuiteValidationError{
							field:  fmt.Sprintf("Resources[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, TestSuiteValidationError{
							field:  fmt.Sprintf("Resources[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return TestSuiteValidationError{
						field:  fmt.Sprintf("Resources[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	{
		sorted_keys := make([]string, len(m.GetAuxData()))
		i := 0
		for key := range m.GetAuxData() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetAuxData()[key]
			_ = val

			// no validation rules for AuxData[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, TestSuiteValidationError{
							field:  fmt.Sprintf("AuxData[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, TestSuiteValidationError{
							field:  fmt.Sprintf("AuxData[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return TestSuiteValidationError{
						field:  fmt.Sprintf("AuxData[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return TestSuiteMultiError(errors)
	}

	return nil
}

// TestSuiteMultiError is an error wrapping multiple validation errors returned
// by TestSuite.ValidateAll() if the designated constraints aren't met.
type TestSuiteMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestSuiteMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestSuiteMultiError) AllErrors() []error { return m }

// TestSuiteValidationError is the validation error returned by
// TestSuite.Validate if the designated constraints aren't met.
type TestSuiteValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestSuiteValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestSuiteValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestSuiteValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestSuiteValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestSuiteValidationError) ErrorName() string { return "TestSuiteValidationError" }

// Error satisfies the builtin error interface
func (e TestSuiteValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestSuite.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestSuiteValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestSuiteValidationError{}

// Validate checks the field values on TestTable with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TestTable) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestTable with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TestTableMultiError, or nil
// if none found.
func (m *TestTable) ValidateAll() error {
	return m.validate(true)
}

func (m *TestTable) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := TestTableValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Description

	// no validation rules for Skip

	// no validation rules for SkipReason

	if m.GetInput() == nil {
		err := TestTableValidationError{
			field:  "Input",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetInput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TestTableValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TestTableValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TestTableValidationError{
				field:  "Input",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(m.GetExpected()) < 1 {
		err := TestTableValidationError{
			field:  "Expected",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetExpected() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TestTableValidationError{
						field:  fmt.Sprintf("Expected[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TestTableValidationError{
						field:  fmt.Sprintf("Expected[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TestTableValidationError{
					field:  fmt.Sprintf("Expected[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TestTableMultiError(errors)
	}

	return nil
}

// TestTableMultiError is an error wrapping multiple validation errors returned
// by TestTable.ValidateAll() if the designated constraints aren't met.
type TestTableMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestTableMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestTableMultiError) AllErrors() []error { return m }

// TestTableValidationError is the validation error returned by
// TestTable.Validate if the designated constraints aren't met.
type TestTableValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestTableValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestTableValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestTableValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestTableValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestTableValidationError) ErrorName() string { return "TestTableValidationError" }

// Error satisfies the builtin error interface
func (e TestTableValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestTable.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestTableValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestTableValidationError{}

// Validate checks the field values on Test with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Test) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Test with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TestMultiError, or nil if none found.
func (m *Test) ValidateAll() error {
	return m.validate(true)
}

func (m *Test) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetName() == nil {
		err := TestValidationError{
			field:  "Name",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetName()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TestValidationError{
					field:  "Name",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TestValidationError{
					field:  "Name",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetName()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TestValidationError{
				field:  "Name",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Description

	// no validation rules for Skip

	// no validation rules for SkipReason

	if m.GetInput() == nil {
		err := TestValidationError{
			field:  "Input",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetInput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TestValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TestValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TestValidationError{
				field:  "Input",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(m.GetExpected()) < 1 {
		err := TestValidationError{
			field:  "Expected",
			reason: "value must contain at least 1 pair(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	{
		sorted_keys := make([]string, len(m.GetExpected()))
		i := 0
		for key := range m.GetExpected() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetExpected()[key]
			_ = val

			if utf8.RuneCountInString(key) < 1 {
				err := TestValidationError{
					field:  fmt.Sprintf("Expected[%v]", key),
					reason: "value length must be at least 1 runes",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			// no validation rules for Expected[key]
		}
	}

	if len(errors) > 0 {
		return TestMultiError(errors)
	}

	return nil
}

// TestMultiError is an error wrapping multiple validation errors returned by
// Test.ValidateAll() if the designated constraints aren't met.
type TestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestMultiError) AllErrors() []error { return m }

// TestValidationError is the validation error returned by Test.Validate if the
// designated constraints aren't met.
type TestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestValidationError) ErrorName() string { return "TestValidationError" }

// Error satisfies the builtin error interface
func (e TestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestValidationError{}

// Validate checks the field values on TestResults with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TestResults) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestResults with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TestResultsMultiError, or
// nil if none found.
func (m *TestResults) ValidateAll() error {
	return m.validate(true)
}

func (m *TestResults) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSuites() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TestResultsValidationError{
						field:  fmt.Sprintf("Suites[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TestResultsValidationError{
						field:  fmt.Sprintf("Suites[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TestResultsValidationError{
					field:  fmt.Sprintf("Suites[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetSummary()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TestResultsValidationError{
					field:  "Summary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TestResultsValidationError{
					field:  "Summary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSummary()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TestResultsValidationError{
				field:  "Summary",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TestResultsMultiError(errors)
	}

	return nil
}

// TestResultsMultiError is an error wrapping multiple validation errors
// returned by TestResults.ValidateAll() if the designated constraints aren't met.
type TestResultsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestResultsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestResultsMultiError) AllErrors() []error { return m }

// TestResultsValidationError is the validation error returned by
// TestResults.Validate if the designated constraints aren't met.
type TestResultsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestResultsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestResultsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestResultsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestResultsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestResultsValidationError) ErrorName() string { return "TestResultsValidationError" }

// Error satisfies the builtin error interface
func (e TestResultsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestResults.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestResultsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestResultsValidationError{}

// Validate checks the field values on PrincipalRule_Action with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PrincipalRule_Action) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PrincipalRule_Action with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PrincipalRule_ActionMultiError, or nil if none found.
func (m *PrincipalRule_Action) ValidateAll() error {
	return m.validate(true)
}

func (m *PrincipalRule_Action) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAction()) < 1 {
		err := PrincipalRule_ActionValidationError{
			field:  "Action",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCondition()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PrincipalRule_ActionValidationError{
					field:  "Condition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PrincipalRule_ActionValidationError{
					field:  "Condition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCondition()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PrincipalRule_ActionValidationError{
				field:  "Condition",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if _, ok := _PrincipalRule_Action_Effect_InLookup[m.GetEffect()]; !ok {
		err := PrincipalRule_ActionValidationError{
			field:  "Effect",
			reason: "value must be in list [1 2]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_PrincipalRule_Action_Name_Pattern.MatchString(m.GetName()) {
		err := PrincipalRule_ActionValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^([[:alpha:]][[:word:]\\\\@\\\\.\\\\-]*)*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return PrincipalRule_ActionMultiError(errors)
	}

	return nil
}

// PrincipalRule_ActionMultiError is an error wrapping multiple validation
// errors returned by PrincipalRule_Action.ValidateAll() if the designated
// constraints aren't met.
type PrincipalRule_ActionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PrincipalRule_ActionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PrincipalRule_ActionMultiError) AllErrors() []error { return m }

// PrincipalRule_ActionValidationError is the validation error returned by
// PrincipalRule_Action.Validate if the designated constraints aren't met.
type PrincipalRule_ActionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PrincipalRule_ActionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PrincipalRule_ActionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PrincipalRule_ActionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PrincipalRule_ActionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PrincipalRule_ActionValidationError) ErrorName() string {
	return "PrincipalRule_ActionValidationError"
}

// Error satisfies the builtin error interface
func (e PrincipalRule_ActionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPrincipalRule_Action.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PrincipalRule_ActionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PrincipalRule_ActionValidationError{}

var _PrincipalRule_Action_Effect_InLookup = map[effectv1.Effect]struct{}{
	1: {},
	2: {},
}

var _PrincipalRule_Action_Name_Pattern = regexp.MustCompile("^([[:alpha:]][[:word:]\\@\\.\\-]*)*$")

// Validate checks the field values on Match_ExprList with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Match_ExprList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Match_ExprList with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Match_ExprListMultiError,
// or nil if none found.
func (m *Match_ExprList) ValidateAll() error {
	return m.validate(true)
}

func (m *Match_ExprList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetOf()) < 1 {
		err := Match_ExprListValidationError{
			field:  "Of",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetOf() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Match_ExprListValidationError{
						field:  fmt.Sprintf("Of[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Match_ExprListValidationError{
						field:  fmt.Sprintf("Of[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Match_ExprListValidationError{
					field:  fmt.Sprintf("Of[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return Match_ExprListMultiError(errors)
	}

	return nil
}

// Match_ExprListMultiError is an error wrapping multiple validation errors
// returned by Match_ExprList.ValidateAll() if the designated constraints
// aren't met.
type Match_ExprListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Match_ExprListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Match_ExprListMultiError) AllErrors() []error { return m }

// Match_ExprListValidationError is the validation error returned by
// Match_ExprList.Validate if the designated constraints aren't met.
type Match_ExprListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Match_ExprListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Match_ExprListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Match_ExprListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Match_ExprListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Match_ExprListValidationError) ErrorName() string { return "Match_ExprListValidationError" }

// Error satisfies the builtin error interface
func (e Match_ExprListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMatch_ExprList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Match_ExprListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Match_ExprListValidationError{}

// Validate checks the field values on Schemas_IgnoreWhen with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Schemas_IgnoreWhen) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Schemas_IgnoreWhen with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Schemas_IgnoreWhenMultiError, or nil if none found.
func (m *Schemas_IgnoreWhen) ValidateAll() error {
	return m.validate(true)
}

func (m *Schemas_IgnoreWhen) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetActions()) < 1 {
		err := Schemas_IgnoreWhenValidationError{
			field:  "Actions",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_Schemas_IgnoreWhen_Actions_Unique := make(map[string]struct{}, len(m.GetActions()))

	for idx, item := range m.GetActions() {
		_, _ = idx, item

		if _, exists := _Schemas_IgnoreWhen_Actions_Unique[item]; exists {
			err := Schemas_IgnoreWhenValidationError{
				field:  fmt.Sprintf("Actions[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_Schemas_IgnoreWhen_Actions_Unique[item] = struct{}{}
		}

		if utf8.RuneCountInString(item) < 1 {
			err := Schemas_IgnoreWhenValidationError{
				field:  fmt.Sprintf("Actions[%v]", idx),
				reason: "value length must be at least 1 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return Schemas_IgnoreWhenMultiError(errors)
	}

	return nil
}

// Schemas_IgnoreWhenMultiError is an error wrapping multiple validation errors
// returned by Schemas_IgnoreWhen.ValidateAll() if the designated constraints
// aren't met.
type Schemas_IgnoreWhenMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Schemas_IgnoreWhenMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Schemas_IgnoreWhenMultiError) AllErrors() []error { return m }

// Schemas_IgnoreWhenValidationError is the validation error returned by
// Schemas_IgnoreWhen.Validate if the designated constraints aren't met.
type Schemas_IgnoreWhenValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Schemas_IgnoreWhenValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Schemas_IgnoreWhenValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Schemas_IgnoreWhenValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Schemas_IgnoreWhenValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Schemas_IgnoreWhenValidationError) ErrorName() string {
	return "Schemas_IgnoreWhenValidationError"
}

// Error satisfies the builtin error interface
func (e Schemas_IgnoreWhenValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSchemas_IgnoreWhen.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Schemas_IgnoreWhenValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Schemas_IgnoreWhenValidationError{}

// Validate checks the field values on Schemas_Schema with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Schemas_Schema) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Schemas_Schema with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Schemas_SchemaMultiError,
// or nil if none found.
func (m *Schemas_Schema) ValidateAll() error {
	return m.validate(true)
}

func (m *Schemas_Schema) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetRef()) < 1 {
		err := Schemas_SchemaValidationError{
			field:  "Ref",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetIgnoreWhen()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Schemas_SchemaValidationError{
					field:  "IgnoreWhen",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Schemas_SchemaValidationError{
					field:  "IgnoreWhen",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIgnoreWhen()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Schemas_SchemaValidationError{
				field:  "IgnoreWhen",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Schemas_SchemaMultiError(errors)
	}

	return nil
}

// Schemas_SchemaMultiError is an error wrapping multiple validation errors
// returned by Schemas_Schema.ValidateAll() if the designated constraints
// aren't met.
type Schemas_SchemaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Schemas_SchemaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Schemas_SchemaMultiError) AllErrors() []error { return m }

// Schemas_SchemaValidationError is the validation error returned by
// Schemas_Schema.Validate if the designated constraints aren't met.
type Schemas_SchemaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Schemas_SchemaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Schemas_SchemaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Schemas_SchemaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Schemas_SchemaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Schemas_SchemaValidationError) ErrorName() string { return "Schemas_SchemaValidationError" }

// Error satisfies the builtin error interface
func (e Schemas_SchemaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSchemas_Schema.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Schemas_SchemaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Schemas_SchemaValidationError{}

// Validate checks the field values on TestFixture_Principals with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestFixture_Principals) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestFixture_Principals with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestFixture_PrincipalsMultiError, or nil if none found.
func (m *TestFixture_Principals) ValidateAll() error {
	return m.validate(true)
}

func (m *TestFixture_Principals) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetPrincipals()))
		i := 0
		for key := range m.GetPrincipals() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetPrincipals()[key]
			_ = val

			// no validation rules for Principals[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, TestFixture_PrincipalsValidationError{
							field:  fmt.Sprintf("Principals[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, TestFixture_PrincipalsValidationError{
							field:  fmt.Sprintf("Principals[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return TestFixture_PrincipalsValidationError{
						field:  fmt.Sprintf("Principals[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return TestFixture_PrincipalsMultiError(errors)
	}

	return nil
}

// TestFixture_PrincipalsMultiError is an error wrapping multiple validation
// errors returned by TestFixture_Principals.ValidateAll() if the designated
// constraints aren't met.
type TestFixture_PrincipalsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestFixture_PrincipalsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestFixture_PrincipalsMultiError) AllErrors() []error { return m }

// TestFixture_PrincipalsValidationError is the validation error returned by
// TestFixture_Principals.Validate if the designated constraints aren't met.
type TestFixture_PrincipalsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestFixture_PrincipalsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestFixture_PrincipalsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestFixture_PrincipalsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestFixture_PrincipalsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestFixture_PrincipalsValidationError) ErrorName() string {
	return "TestFixture_PrincipalsValidationError"
}

// Error satisfies the builtin error interface
func (e TestFixture_PrincipalsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestFixture_Principals.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestFixture_PrincipalsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestFixture_PrincipalsValidationError{}

// Validate checks the field values on TestFixture_Resources with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestFixture_Resources) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestFixture_Resources with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestFixture_ResourcesMultiError, or nil if none found.
func (m *TestFixture_Resources) ValidateAll() error {
	return m.validate(true)
}

func (m *TestFixture_Resources) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetResources()))
		i := 0
		for key := range m.GetResources() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetResources()[key]
			_ = val

			// no validation rules for Resources[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, TestFixture_ResourcesValidationError{
							field:  fmt.Sprintf("Resources[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, TestFixture_ResourcesValidationError{
							field:  fmt.Sprintf("Resources[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return TestFixture_ResourcesValidationError{
						field:  fmt.Sprintf("Resources[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return TestFixture_ResourcesMultiError(errors)
	}

	return nil
}

// TestFixture_ResourcesMultiError is an error wrapping multiple validation
// errors returned by TestFixture_Resources.ValidateAll() if the designated
// constraints aren't met.
type TestFixture_ResourcesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestFixture_ResourcesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestFixture_ResourcesMultiError) AllErrors() []error { return m }

// TestFixture_ResourcesValidationError is the validation error returned by
// TestFixture_Resources.Validate if the designated constraints aren't met.
type TestFixture_ResourcesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestFixture_ResourcesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestFixture_ResourcesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestFixture_ResourcesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestFixture_ResourcesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestFixture_ResourcesValidationError) ErrorName() string {
	return "TestFixture_ResourcesValidationError"
}

// Error satisfies the builtin error interface
func (e TestFixture_ResourcesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestFixture_Resources.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestFixture_ResourcesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestFixture_ResourcesValidationError{}

// Validate checks the field values on TestFixture_AuxData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestFixture_AuxData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestFixture_AuxData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestFixture_AuxDataMultiError, or nil if none found.
func (m *TestFixture_AuxData) ValidateAll() error {
	return m.validate(true)
}

func (m *TestFixture_AuxData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetAuxData()))
		i := 0
		for key := range m.GetAuxData() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetAuxData()[key]
			_ = val

			// no validation rules for AuxData[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, TestFixture_AuxDataValidationError{
							field:  fmt.Sprintf("AuxData[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, TestFixture_AuxDataValidationError{
							field:  fmt.Sprintf("AuxData[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return TestFixture_AuxDataValidationError{
						field:  fmt.Sprintf("AuxData[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return TestFixture_AuxDataMultiError(errors)
	}

	return nil
}

// TestFixture_AuxDataMultiError is an error wrapping multiple validation
// errors returned by TestFixture_AuxData.ValidateAll() if the designated
// constraints aren't met.
type TestFixture_AuxDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestFixture_AuxDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestFixture_AuxDataMultiError) AllErrors() []error { return m }

// TestFixture_AuxDataValidationError is the validation error returned by
// TestFixture_AuxData.Validate if the designated constraints aren't met.
type TestFixture_AuxDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestFixture_AuxDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestFixture_AuxDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestFixture_AuxDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestFixture_AuxDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestFixture_AuxDataValidationError) ErrorName() string {
	return "TestFixture_AuxDataValidationError"
}

// Error satisfies the builtin error interface
func (e TestFixture_AuxDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestFixture_AuxData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestFixture_AuxDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestFixture_AuxDataValidationError{}

// Validate checks the field values on TestTable_Input with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TestTable_Input) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestTable_Input with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestTable_InputMultiError, or nil if none found.
func (m *TestTable_Input) ValidateAll() error {
	return m.validate(true)
}

func (m *TestTable_Input) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetPrincipals()) < 1 {
		err := TestTable_InputValidationError{
			field:  "Principals",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_TestTable_Input_Principals_Unique := make(map[string]struct{}, len(m.GetPrincipals()))

	for idx, item := range m.GetPrincipals() {
		_, _ = idx, item

		if _, exists := _TestTable_Input_Principals_Unique[item]; exists {
			err := TestTable_InputValidationError{
				field:  fmt.Sprintf("Principals[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_TestTable_Input_Principals_Unique[item] = struct{}{}
		}

		if utf8.RuneCountInString(item) < 1 {
			err := TestTable_InputValidationError{
				field:  fmt.Sprintf("Principals[%v]", idx),
				reason: "value length must be at least 1 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(m.GetResources()) < 1 {
		err := TestTable_InputValidationError{
			field:  "Resources",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_TestTable_Input_Resources_Unique := make(map[string]struct{}, len(m.GetResources()))

	for idx, item := range m.GetResources() {
		_, _ = idx, item

		if _, exists := _TestTable_Input_Resources_Unique[item]; exists {
			err := TestTable_InputValidationError{
				field:  fmt.Sprintf("Resources[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_TestTable_Input_Resources_Unique[item] = struct{}{}
		}

		if utf8.RuneCountInString(item) < 1 {
			err := TestTable_InputValidationError{
				field:  fmt.Sprintf("Resources[%v]", idx),
				reason: "value length must be at least 1 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(m.GetActions()) < 1 {
		err := TestTable_InputValidationError{
			field:  "Actions",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_TestTable_Input_Actions_Unique := make(map[string]struct{}, len(m.GetActions()))

	for idx, item := range m.GetActions() {
		_, _ = idx, item

		if _, exists := _TestTable_Input_Actions_Unique[item]; exists {
			err := TestTable_InputValidationError{
				field:  fmt.Sprintf("Actions[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_TestTable_Input_Actions_Unique[item] = struct{}{}
		}

		if utf8.RuneCountInString(item) < 1 {
			err := TestTable_InputValidationError{
				field:  fmt.Sprintf("Actions[%v]", idx),
				reason: "value length must be at least 1 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for AuxData

	if len(errors) > 0 {
		return TestTable_InputMultiError(errors)
	}

	return nil
}

// TestTable_InputMultiError is an error wrapping multiple validation errors
// returned by TestTable_Input.ValidateAll() if the designated constraints
// aren't met.
type TestTable_InputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestTable_InputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestTable_InputMultiError) AllErrors() []error { return m }

// TestTable_InputValidationError is the validation error returned by
// TestTable_Input.Validate if the designated constraints aren't met.
type TestTable_InputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestTable_InputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestTable_InputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestTable_InputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestTable_InputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestTable_InputValidationError) ErrorName() string { return "TestTable_InputValidationError" }

// Error satisfies the builtin error interface
func (e TestTable_InputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestTable_Input.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestTable_InputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestTable_InputValidationError{}

// Validate checks the field values on TestTable_Expectation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestTable_Expectation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestTable_Expectation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestTable_ExpectationMultiError, or nil if none found.
func (m *TestTable_Expectation) ValidateAll() error {
	return m.validate(true)
}

func (m *TestTable_Expectation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetPrincipal()) < 1 {
		err := TestTable_ExpectationValidationError{
			field:  "Principal",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetResource()) < 1 {
		err := TestTable_ExpectationValidationError{
			field:  "Resource",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetActions()) < 1 {
		err := TestTable_ExpectationValidationError{
			field:  "Actions",
			reason: "value must contain at least 1 pair(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	{
		sorted_keys := make([]string, len(m.GetActions()))
		i := 0
		for key := range m.GetActions() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetActions()[key]
			_ = val

			if utf8.RuneCountInString(key) < 1 {
				err := TestTable_ExpectationValidationError{
					field:  fmt.Sprintf("Actions[%v]", key),
					reason: "value length must be at least 1 runes",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			// no validation rules for Actions[key]
		}
	}

	if len(errors) > 0 {
		return TestTable_ExpectationMultiError(errors)
	}

	return nil
}

// TestTable_ExpectationMultiError is an error wrapping multiple validation
// errors returned by TestTable_Expectation.ValidateAll() if the designated
// constraints aren't met.
type TestTable_ExpectationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestTable_ExpectationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestTable_ExpectationMultiError) AllErrors() []error { return m }

// TestTable_ExpectationValidationError is the validation error returned by
// TestTable_Expectation.Validate if the designated constraints aren't met.
type TestTable_ExpectationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestTable_ExpectationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestTable_ExpectationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestTable_ExpectationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestTable_ExpectationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestTable_ExpectationValidationError) ErrorName() string {
	return "TestTable_ExpectationValidationError"
}

// Error satisfies the builtin error interface
func (e TestTable_ExpectationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestTable_Expectation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestTable_ExpectationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestTable_ExpectationValidationError{}

// Validate checks the field values on Test_TestName with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Test_TestName) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Test_TestName with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Test_TestNameMultiError, or
// nil if none found.
func (m *Test_TestName) ValidateAll() error {
	return m.validate(true)
}

func (m *Test_TestName) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetTestTableName()) < 1 {
		err := Test_TestNameValidationError{
			field:  "TestTableName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPrincipalKey()) < 1 {
		err := Test_TestNameValidationError{
			field:  "PrincipalKey",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetResourceKey()) < 1 {
		err := Test_TestNameValidationError{
			field:  "ResourceKey",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return Test_TestNameMultiError(errors)
	}

	return nil
}

// Test_TestNameMultiError is an error wrapping multiple validation errors
// returned by Test_TestName.ValidateAll() if the designated constraints
// aren't met.
type Test_TestNameMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Test_TestNameMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Test_TestNameMultiError) AllErrors() []error { return m }

// Test_TestNameValidationError is the validation error returned by
// Test_TestName.Validate if the designated constraints aren't met.
type Test_TestNameValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Test_TestNameValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Test_TestNameValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Test_TestNameValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Test_TestNameValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Test_TestNameValidationError) ErrorName() string { return "Test_TestNameValidationError" }

// Error satisfies the builtin error interface
func (e Test_TestNameValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTest_TestName.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Test_TestNameValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Test_TestNameValidationError{}

// Validate checks the field values on TestResults_Tally with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TestResults_Tally) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestResults_Tally with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestResults_TallyMultiError, or nil if none found.
func (m *TestResults_Tally) ValidateAll() error {
	return m.validate(true)
}

func (m *TestResults_Tally) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Result

	// no validation rules for Count

	if len(errors) > 0 {
		return TestResults_TallyMultiError(errors)
	}

	return nil
}

// TestResults_TallyMultiError is an error wrapping multiple validation errors
// returned by TestResults_Tally.ValidateAll() if the designated constraints
// aren't met.
type TestResults_TallyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestResults_TallyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestResults_TallyMultiError) AllErrors() []error { return m }

// TestResults_TallyValidationError is the validation error returned by
// TestResults_Tally.Validate if the designated constraints aren't met.
type TestResults_TallyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestResults_TallyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestResults_TallyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestResults_TallyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestResults_TallyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestResults_TallyValidationError) ErrorName() string {
	return "TestResults_TallyValidationError"
}

// Error satisfies the builtin error interface
func (e TestResults_TallyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestResults_Tally.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestResults_TallyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestResults_TallyValidationError{}

// Validate checks the field values on TestResults_Summary with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestResults_Summary) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestResults_Summary with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestResults_SummaryMultiError, or nil if none found.
func (m *TestResults_Summary) ValidateAll() error {
	return m.validate(true)
}

func (m *TestResults_Summary) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OverallResult

	// no validation rules for TestsCount

	for idx, item := range m.GetResultCounts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TestResults_SummaryValidationError{
						field:  fmt.Sprintf("ResultCounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TestResults_SummaryValidationError{
						field:  fmt.Sprintf("ResultCounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TestResults_SummaryValidationError{
					field:  fmt.Sprintf("ResultCounts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TestResults_SummaryMultiError(errors)
	}

	return nil
}

// TestResults_SummaryMultiError is an error wrapping multiple validation
// errors returned by TestResults_Summary.ValidateAll() if the designated
// constraints aren't met.
type TestResults_SummaryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestResults_SummaryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestResults_SummaryMultiError) AllErrors() []error { return m }

// TestResults_SummaryValidationError is the validation error returned by
// TestResults_Summary.Validate if the designated constraints aren't met.
type TestResults_SummaryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestResults_SummaryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestResults_SummaryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestResults_SummaryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestResults_SummaryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestResults_SummaryValidationError) ErrorName() string {
	return "TestResults_SummaryValidationError"
}

// Error satisfies the builtin error interface
func (e TestResults_SummaryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestResults_Summary.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestResults_SummaryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestResults_SummaryValidationError{}

// Validate checks the field values on TestResults_Suite with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TestResults_Suite) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestResults_Suite with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestResults_SuiteMultiError, or nil if none found.
func (m *TestResults_Suite) ValidateAll() error {
	return m.validate(true)
}

func (m *TestResults_Suite) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for File

	// no validation rules for Name

	for idx, item := range m.GetPrincipals() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TestResults_SuiteValidationError{
						field:  fmt.Sprintf("Principals[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TestResults_SuiteValidationError{
						field:  fmt.Sprintf("Principals[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TestResults_SuiteValidationError{
					field:  fmt.Sprintf("Principals[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetSummary()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TestResults_SuiteValidationError{
					field:  "Summary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TestResults_SuiteValidationError{
					field:  "Summary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSummary()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TestResults_SuiteValidationError{
				field:  "Summary",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Error

	if len(errors) > 0 {
		return TestResults_SuiteMultiError(errors)
	}

	return nil
}

// TestResults_SuiteMultiError is an error wrapping multiple validation errors
// returned by TestResults_Suite.ValidateAll() if the designated constraints
// aren't met.
type TestResults_SuiteMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestResults_SuiteMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestResults_SuiteMultiError) AllErrors() []error { return m }

// TestResults_SuiteValidationError is the validation error returned by
// TestResults_Suite.Validate if the designated constraints aren't met.
type TestResults_SuiteValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestResults_SuiteValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestResults_SuiteValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestResults_SuiteValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestResults_SuiteValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestResults_SuiteValidationError) ErrorName() string {
	return "TestResults_SuiteValidationError"
}

// Error satisfies the builtin error interface
func (e TestResults_SuiteValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestResults_Suite.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestResults_SuiteValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestResults_SuiteValidationError{}

// Validate checks the field values on TestResults_Principal with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestResults_Principal) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestResults_Principal with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestResults_PrincipalMultiError, or nil if none found.
func (m *TestResults_Principal) ValidateAll() error {
	return m.validate(true)
}

func (m *TestResults_Principal) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	for idx, item := range m.GetResources() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TestResults_PrincipalValidationError{
						field:  fmt.Sprintf("Resources[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TestResults_PrincipalValidationError{
						field:  fmt.Sprintf("Resources[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TestResults_PrincipalValidationError{
					field:  fmt.Sprintf("Resources[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TestResults_PrincipalMultiError(errors)
	}

	return nil
}

// TestResults_PrincipalMultiError is an error wrapping multiple validation
// errors returned by TestResults_Principal.ValidateAll() if the designated
// constraints aren't met.
type TestResults_PrincipalMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestResults_PrincipalMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestResults_PrincipalMultiError) AllErrors() []error { return m }

// TestResults_PrincipalValidationError is the validation error returned by
// TestResults_Principal.Validate if the designated constraints aren't met.
type TestResults_PrincipalValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestResults_PrincipalValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestResults_PrincipalValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestResults_PrincipalValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestResults_PrincipalValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestResults_PrincipalValidationError) ErrorName() string {
	return "TestResults_PrincipalValidationError"
}

// Error satisfies the builtin error interface
func (e TestResults_PrincipalValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestResults_Principal.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestResults_PrincipalValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestResults_PrincipalValidationError{}

// Validate checks the field values on TestResults_Resource with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestResults_Resource) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestResults_Resource with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestResults_ResourceMultiError, or nil if none found.
func (m *TestResults_Resource) ValidateAll() error {
	return m.validate(true)
}

func (m *TestResults_Resource) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	for idx, item := range m.GetActions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TestResults_ResourceValidationError{
						field:  fmt.Sprintf("Actions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TestResults_ResourceValidationError{
						field:  fmt.Sprintf("Actions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TestResults_ResourceValidationError{
					field:  fmt.Sprintf("Actions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TestResults_ResourceMultiError(errors)
	}

	return nil
}

// TestResults_ResourceMultiError is an error wrapping multiple validation
// errors returned by TestResults_Resource.ValidateAll() if the designated
// constraints aren't met.
type TestResults_ResourceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestResults_ResourceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestResults_ResourceMultiError) AllErrors() []error { return m }

// TestResults_ResourceValidationError is the validation error returned by
// TestResults_Resource.Validate if the designated constraints aren't met.
type TestResults_ResourceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestResults_ResourceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestResults_ResourceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestResults_ResourceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestResults_ResourceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestResults_ResourceValidationError) ErrorName() string {
	return "TestResults_ResourceValidationError"
}

// Error satisfies the builtin error interface
func (e TestResults_ResourceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestResults_Resource.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestResults_ResourceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestResults_ResourceValidationError{}

// Validate checks the field values on TestResults_Action with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestResults_Action) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestResults_Action with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestResults_ActionMultiError, or nil if none found.
func (m *TestResults_Action) ValidateAll() error {
	return m.validate(true)
}

func (m *TestResults_Action) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetDetails()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TestResults_ActionValidationError{
					field:  "Details",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TestResults_ActionValidationError{
					field:  "Details",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDetails()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TestResults_ActionValidationError{
				field:  "Details",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TestResults_ActionMultiError(errors)
	}

	return nil
}

// TestResults_ActionMultiError is an error wrapping multiple validation errors
// returned by TestResults_Action.ValidateAll() if the designated constraints
// aren't met.
type TestResults_ActionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestResults_ActionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestResults_ActionMultiError) AllErrors() []error { return m }

// TestResults_ActionValidationError is the validation error returned by
// TestResults_Action.Validate if the designated constraints aren't met.
type TestResults_ActionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestResults_ActionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestResults_ActionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestResults_ActionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestResults_ActionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestResults_ActionValidationError) ErrorName() string {
	return "TestResults_ActionValidationError"
}

// Error satisfies the builtin error interface
func (e TestResults_ActionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestResults_Action.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestResults_ActionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestResults_ActionValidationError{}

// Validate checks the field values on TestResults_Details with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestResults_Details) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestResults_Details with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestResults_DetailsMultiError, or nil if none found.
func (m *TestResults_Details) ValidateAll() error {
	return m.validate(true)
}

func (m *TestResults_Details) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Result

	for idx, item := range m.GetEngineTrace() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TestResults_DetailsValidationError{
						field:  fmt.Sprintf("EngineTrace[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TestResults_DetailsValidationError{
						field:  fmt.Sprintf("EngineTrace[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TestResults_DetailsValidationError{
					field:  fmt.Sprintf("EngineTrace[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	switch m.Outcome.(type) {

	case *TestResults_Details_Failure:

		if all {
			switch v := interface{}(m.GetFailure()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TestResults_DetailsValidationError{
						field:  "Failure",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TestResults_DetailsValidationError{
						field:  "Failure",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFailure()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TestResults_DetailsValidationError{
					field:  "Failure",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TestResults_Details_Error:
		// no validation rules for Error

	}

	if len(errors) > 0 {
		return TestResults_DetailsMultiError(errors)
	}

	return nil
}

// TestResults_DetailsMultiError is an error wrapping multiple validation
// errors returned by TestResults_Details.ValidateAll() if the designated
// constraints aren't met.
type TestResults_DetailsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestResults_DetailsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestResults_DetailsMultiError) AllErrors() []error { return m }

// TestResults_DetailsValidationError is the validation error returned by
// TestResults_Details.Validate if the designated constraints aren't met.
type TestResults_DetailsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestResults_DetailsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestResults_DetailsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestResults_DetailsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestResults_DetailsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestResults_DetailsValidationError) ErrorName() string {
	return "TestResults_DetailsValidationError"
}

// Error satisfies the builtin error interface
func (e TestResults_DetailsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestResults_Details.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestResults_DetailsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestResults_DetailsValidationError{}

// Validate checks the field values on TestResults_Failure with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestResults_Failure) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestResults_Failure with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestResults_FailureMultiError, or nil if none found.
func (m *TestResults_Failure) ValidateAll() error {
	return m.validate(true)
}

func (m *TestResults_Failure) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Expected

	// no validation rules for Actual

	if len(errors) > 0 {
		return TestResults_FailureMultiError(errors)
	}

	return nil
}

// TestResults_FailureMultiError is an error wrapping multiple validation
// errors returned by TestResults_Failure.ValidateAll() if the designated
// constraints aren't met.
type TestResults_FailureMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestResults_FailureMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestResults_FailureMultiError) AllErrors() []error { return m }

// TestResults_FailureValidationError is the validation error returned by
// TestResults_Failure.Validate if the designated constraints aren't met.
type TestResults_FailureValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestResults_FailureValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestResults_FailureValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestResults_FailureValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestResults_FailureValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestResults_FailureValidationError) ErrorName() string {
	return "TestResults_FailureValidationError"
}

// Error satisfies the builtin error interface
func (e TestResults_FailureValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestResults_Failure.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestResults_FailureValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestResults_FailureValidationError{}
