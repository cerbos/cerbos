// Code generated by protoc-gen-go-hashpb. DO NOT EDIT.
// protoc-gen-go-hashpb v0.5.0

package runtimev1

import (
	v1 "github.com/cerbos/cerbos/api/genpb/cerbos/policy/v1"
	v11 "github.com/cerbos/cerbos/api/genpb/cerbos/source/v1"
	v1alpha1 "google.golang.org/genproto/googleapis/api/expr/v1alpha1"
	protowire "google.golang.org/protobuf/encoding/protowire"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	structpb "google.golang.org/protobuf/types/known/structpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	hash "hash"
	maps "maps"
	math "math"
	slices "slices"
	sync "sync"
	unsafe "unsafe"
)

var hashpb_bufPool = sync.Pool{
	New: func() any { return new([10]byte) },
}

var hashpb_stringKeyPool = sync.Pool{
	New: func() any { return make([]string, 0, 32) },
}

var hashpb_int32KeyPool = sync.Pool{
	New: func() any { return make([]int32, 0, 32) },
}

var hashpb_int64KeyPool = sync.Pool{
	New: func() any { return make([]int64, 0, 32) },
}

var hashpb_uint32KeyPool = sync.Pool{
	New: func() any { return make([]uint32, 0, 32) },
}

var hashpb_uint64KeyPool = sync.Pool{
	New: func() any { return make([]uint64, 0, 32) },
}

func cerbos_policy_v1_Schemas_IgnoreWhen_hashpb_sum(m *v1.Schemas_IgnoreWhen, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.policy.v1.Schemas.IgnoreWhen.actions"]; !ok {
		if len(m.Actions) > 0 {
			for _, v := range m.Actions {
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(v))))
				_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(v), len(v)))
			}
		}
	}
}

func cerbos_policy_v1_Schemas_Schema_hashpb_sum(m *v1.Schemas_Schema, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.policy.v1.Schemas.Schema.ref"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetRef()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetRef()), len(m.GetRef())))
	}
	if _, ok := ignore["cerbos.policy.v1.Schemas.Schema.ignore_when"]; !ok {
		if m.GetIgnoreWhen() != nil {
			cerbos_policy_v1_Schemas_IgnoreWhen_hashpb_sum(m.GetIgnoreWhen(), hasher, ignore, b)
		}
	}
}

func cerbos_policy_v1_Schemas_hashpb_sum(m *v1.Schemas, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.policy.v1.Schemas.principal_schema"]; !ok {
		if m.GetPrincipalSchema() != nil {
			cerbos_policy_v1_Schemas_Schema_hashpb_sum(m.GetPrincipalSchema(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["cerbos.policy.v1.Schemas.resource_schema"]; !ok {
		if m.GetResourceSchema() != nil {
			cerbos_policy_v1_Schemas_Schema_hashpb_sum(m.GetResourceSchema(), hasher, ignore, b)
		}
	}
}

func cerbos_policy_v1_SourceAttributes_hashpb_sum(m *v1.SourceAttributes, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.policy.v1.SourceAttributes.attributes"]; !ok {
		if len(m.Attributes) > 0 {
			if len(m.Attributes) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.Attributes {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Attributes[k] != nil {
						google_protobuf_Value_hashpb_sum(m.Attributes[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.Attributes)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Attributes[k] != nil {
						google_protobuf_Value_hashpb_sum(m.Attributes[k], hasher, ignore, b)
					}
				}
			}
		}
	}
}

func cerbos_runtime_v1_CompileErrors_Err_hashpb_sum(m *CompileErrors_Err, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.CompileErrors.Err.file"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetFile()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetFile()), len(m.GetFile())))
	}
	if _, ok := ignore["cerbos.runtime.v1.CompileErrors.Err.error"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetError()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetError()), len(m.GetError())))
	}
	if _, ok := ignore["cerbos.runtime.v1.CompileErrors.Err.description"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetDescription()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetDescription()), len(m.GetDescription())))
	}
	if _, ok := ignore["cerbos.runtime.v1.CompileErrors.Err.position"]; !ok {
		if m.GetPosition() != nil {
			cerbos_source_v1_Position_hashpb_sum(m.GetPosition(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.CompileErrors.Err.context"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetContext()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetContext()), len(m.GetContext())))
	}
}

func cerbos_runtime_v1_CompileErrors_hashpb_sum(m *CompileErrors, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.CompileErrors.errors"]; !ok {
		if len(m.Errors) > 0 {
			for _, v := range m.Errors {
				if v != nil {
					cerbos_runtime_v1_CompileErrors_Err_hashpb_sum(v, hasher, ignore, b)
				}
			}
		}
	}
}

func cerbos_runtime_v1_Condition_ExprList_hashpb_sum(m *Condition_ExprList, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.Condition.ExprList.expr"]; !ok {
		if len(m.Expr) > 0 {
			for _, v := range m.Expr {
				if v != nil {
					cerbos_runtime_v1_Condition_hashpb_sum(v, hasher, ignore, b)
				}
			}
		}
	}
}

func cerbos_runtime_v1_Condition_hashpb_sum(m *Condition, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if m.Op != nil {
		if _, ok := ignore["cerbos.runtime.v1.Condition.op"]; !ok {
			switch t := m.Op.(type) {
			case *Condition_All:
				if t.All != nil {
					cerbos_runtime_v1_Condition_ExprList_hashpb_sum(t.All, hasher, ignore, b)
				}
			case *Condition_Any:
				if t.Any != nil {
					cerbos_runtime_v1_Condition_ExprList_hashpb_sum(t.Any, hasher, ignore, b)
				}
			case *Condition_None:
				if t.None != nil {
					cerbos_runtime_v1_Condition_ExprList_hashpb_sum(t.None, hasher, ignore, b)
				}
			case *Condition_Expr:
				if t.Expr != nil {
					cerbos_runtime_v1_Expr_hashpb_sum(t.Expr, hasher, ignore, b)
				}
			}
		}
	}
}

func cerbos_runtime_v1_Errors_hashpb_sum(m *Errors, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if m.Kind != nil {
		if _, ok := ignore["cerbos.runtime.v1.Errors.kind"]; !ok {
			switch t := m.Kind.(type) {
			case *Errors_IndexBuildErrors:
				if t.IndexBuildErrors != nil {
					cerbos_runtime_v1_IndexBuildErrors_hashpb_sum(t.IndexBuildErrors, hasher, ignore, b)
				}
			case *Errors_CompileErrors:
				if t.CompileErrors != nil {
					cerbos_runtime_v1_CompileErrors_hashpb_sum(t.CompileErrors, hasher, ignore, b)
				}
			}
		}
	}
}

func cerbos_runtime_v1_Expr_hashpb_sum(m *Expr, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.Expr.original"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetOriginal()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetOriginal()), len(m.GetOriginal())))
	}
	if _, ok := ignore["cerbos.runtime.v1.Expr.checked"]; !ok {
		if m.GetChecked() != nil {
			google_api_expr_v1alpha1_CheckedExpr_hashpb_sum(m.GetChecked(), hasher, ignore, b)
		}
	}
}

func cerbos_runtime_v1_IndexBuildErrors_Disabled_hashpb_sum(m *IndexBuildErrors_Disabled, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.IndexBuildErrors.Disabled.file"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetFile()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetFile()), len(m.GetFile())))
	}
	if _, ok := ignore["cerbos.runtime.v1.IndexBuildErrors.Disabled.policy"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetPolicy()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetPolicy()), len(m.GetPolicy())))
	}
	if _, ok := ignore["cerbos.runtime.v1.IndexBuildErrors.Disabled.position"]; !ok {
		if m.GetPosition() != nil {
			cerbos_source_v1_Position_hashpb_sum(m.GetPosition(), hasher, ignore, b)
		}
	}
}

func cerbos_runtime_v1_IndexBuildErrors_DuplicateDef_hashpb_sum(m *IndexBuildErrors_DuplicateDef, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.IndexBuildErrors.DuplicateDef.file"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetFile()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetFile()), len(m.GetFile())))
	}
	if _, ok := ignore["cerbos.runtime.v1.IndexBuildErrors.DuplicateDef.other_file"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetOtherFile()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetOtherFile()), len(m.GetOtherFile())))
	}
	if _, ok := ignore["cerbos.runtime.v1.IndexBuildErrors.DuplicateDef.policy"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetPolicy()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetPolicy()), len(m.GetPolicy())))
	}
	if _, ok := ignore["cerbos.runtime.v1.IndexBuildErrors.DuplicateDef.position"]; !ok {
		if m.GetPosition() != nil {
			cerbos_source_v1_Position_hashpb_sum(m.GetPosition(), hasher, ignore, b)
		}
	}
}

func cerbos_runtime_v1_IndexBuildErrors_LoadFailure_hashpb_sum(m *IndexBuildErrors_LoadFailure, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.IndexBuildErrors.LoadFailure.file"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetFile()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetFile()), len(m.GetFile())))
	}
	if _, ok := ignore["cerbos.runtime.v1.IndexBuildErrors.LoadFailure.error"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetError()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetError()), len(m.GetError())))
	}
	if _, ok := ignore["cerbos.runtime.v1.IndexBuildErrors.LoadFailure.error_details"]; !ok {
		if m.GetErrorDetails() != nil {
			cerbos_source_v1_Error_hashpb_sum(m.GetErrorDetails(), hasher, ignore, b)
		}
	}
}

func cerbos_runtime_v1_IndexBuildErrors_MissingImport_hashpb_sum(m *IndexBuildErrors_MissingImport, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.IndexBuildErrors.MissingImport.importing_file"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetImportingFile()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetImportingFile()), len(m.GetImportingFile())))
	}
	if _, ok := ignore["cerbos.runtime.v1.IndexBuildErrors.MissingImport.desc"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetDesc()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetDesc()), len(m.GetDesc())))
	}
	if _, ok := ignore["cerbos.runtime.v1.IndexBuildErrors.MissingImport.importing_policy"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetImportingPolicy()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetImportingPolicy()), len(m.GetImportingPolicy())))
	}
	if _, ok := ignore["cerbos.runtime.v1.IndexBuildErrors.MissingImport.import_kind"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetImportKind()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetImportKind()), len(m.GetImportKind())))
	}
	if _, ok := ignore["cerbos.runtime.v1.IndexBuildErrors.MissingImport.import_name"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetImportName()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetImportName()), len(m.GetImportName())))
	}
	if _, ok := ignore["cerbos.runtime.v1.IndexBuildErrors.MissingImport.position"]; !ok {
		if m.GetPosition() != nil {
			cerbos_source_v1_Position_hashpb_sum(m.GetPosition(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.IndexBuildErrors.MissingImport.context"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetContext()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetContext()), len(m.GetContext())))
	}
}

func cerbos_runtime_v1_IndexBuildErrors_MissingScope_hashpb_sum(m *IndexBuildErrors_MissingScope, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.IndexBuildErrors.MissingScope.missing_policy"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetMissingPolicy()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetMissingPolicy()), len(m.GetMissingPolicy())))
	}
	if _, ok := ignore["cerbos.runtime.v1.IndexBuildErrors.MissingScope.descendants"]; !ok {
		if len(m.Descendants) > 0 {
			for _, v := range m.Descendants {
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(v))))
				_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(v), len(v)))
			}
		}
	}
}

func cerbos_runtime_v1_IndexBuildErrors_ScopePermissionsConflicts_hashpb_sum(m *IndexBuildErrors_ScopePermissionsConflicts, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.IndexBuildErrors.ScopePermissionsConflicts.scope"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetScope()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetScope()), len(m.GetScope())))
	}
}

func cerbos_runtime_v1_IndexBuildErrors_hashpb_sum(m *IndexBuildErrors, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.IndexBuildErrors.disabled"]; !ok {
		if len(m.Disabled) > 0 {
			for _, v := range m.Disabled {
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(v))))
				_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(v), len(v)))
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.IndexBuildErrors.duplicate_defs"]; !ok {
		if len(m.DuplicateDefs) > 0 {
			for _, v := range m.DuplicateDefs {
				if v != nil {
					cerbos_runtime_v1_IndexBuildErrors_DuplicateDef_hashpb_sum(v, hasher, ignore, b)
				}
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.IndexBuildErrors.load_failures"]; !ok {
		if len(m.LoadFailures) > 0 {
			for _, v := range m.LoadFailures {
				if v != nil {
					cerbos_runtime_v1_IndexBuildErrors_LoadFailure_hashpb_sum(v, hasher, ignore, b)
				}
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.IndexBuildErrors.missing_imports"]; !ok {
		if len(m.MissingImports) > 0 {
			for _, v := range m.MissingImports {
				if v != nil {
					cerbos_runtime_v1_IndexBuildErrors_MissingImport_hashpb_sum(v, hasher, ignore, b)
				}
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.IndexBuildErrors.missing_scopes"]; !ok {
		if len(m.MissingScopes) > 0 {
			for _, v := range m.MissingScopes {
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(v))))
				_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(v), len(v)))
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.IndexBuildErrors.disabled_defs"]; !ok {
		if len(m.DisabledDefs) > 0 {
			for _, v := range m.DisabledDefs {
				if v != nil {
					cerbos_runtime_v1_IndexBuildErrors_Disabled_hashpb_sum(v, hasher, ignore, b)
				}
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.IndexBuildErrors.missing_scope_details"]; !ok {
		if len(m.MissingScopeDetails) > 0 {
			for _, v := range m.MissingScopeDetails {
				if v != nil {
					cerbos_runtime_v1_IndexBuildErrors_MissingScope_hashpb_sum(v, hasher, ignore, b)
				}
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.IndexBuildErrors.scope_permissions_conflicts"]; !ok {
		if len(m.ScopePermissionsConflicts) > 0 {
			for _, v := range m.ScopePermissionsConflicts {
				if v != nil {
					cerbos_runtime_v1_IndexBuildErrors_ScopePermissionsConflicts_hashpb_sum(v, hasher, ignore, b)
				}
			}
		}
	}
}

func cerbos_runtime_v1_Output_When_hashpb_sum(m *Output_When, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.Output.When.rule_activated"]; !ok {
		if m.GetRuleActivated() != nil {
			cerbos_runtime_v1_Expr_hashpb_sum(m.GetRuleActivated(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.Output.When.condition_not_met"]; !ok {
		if m.GetConditionNotMet() != nil {
			cerbos_runtime_v1_Expr_hashpb_sum(m.GetConditionNotMet(), hasher, ignore, b)
		}
	}
}

func cerbos_runtime_v1_Output_hashpb_sum(m *Output, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.Output.when"]; !ok {
		if m.GetWhen() != nil {
			cerbos_runtime_v1_Output_When_hashpb_sum(m.GetWhen(), hasher, ignore, b)
		}
	}
}

func cerbos_runtime_v1_RuleTableMetadata_hashpb_sum(m *RuleTableMetadata, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.RuleTableMetadata.fqn"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetFqn()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetFqn()), len(m.GetFqn())))
	}
	if m.Name != nil {
		if _, ok := ignore["cerbos.runtime.v1.RuleTableMetadata.name"]; !ok {
			switch t := m.Name.(type) {
			case *RuleTableMetadata_Resource:
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(t.Resource))))
				_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(t.Resource), len(t.Resource)))
			case *RuleTableMetadata_Role:
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(t.Role))))
				_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(t.Role), len(t.Role)))
			case *RuleTableMetadata_Principal:
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(t.Principal))))
				_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(t.Principal), len(t.Principal)))
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RuleTableMetadata.version"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetVersion()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetVersion()), len(m.GetVersion())))
	}
	if _, ok := ignore["cerbos.runtime.v1.RuleTableMetadata.source_attributes"]; !ok {
		if len(m.SourceAttributes) > 0 {
			if len(m.SourceAttributes) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.SourceAttributes {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.SourceAttributes[k] != nil {
						cerbos_policy_v1_SourceAttributes_hashpb_sum(m.SourceAttributes[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.SourceAttributes)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.SourceAttributes[k] != nil {
						cerbos_policy_v1_SourceAttributes_hashpb_sum(m.SourceAttributes[k], hasher, ignore, b)
					}
				}
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RuleTableMetadata.annotations"]; !ok {
		if len(m.Annotations) > 0 {
			if len(m.Annotations) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.Annotations {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.Annotations[k]))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.Annotations[k]), len(m.Annotations[k])))
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.Annotations)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.Annotations[k]))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.Annotations[k]), len(m.Annotations[k])))
				}
			}
		}
	}
}

func cerbos_runtime_v1_RuleTable_JSONSchema_hashpb_sum(m *RuleTable_JSONSchema, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.RuleTable.JSONSchema.content"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetContent()))))
		_, _ = hasher.Write(m.GetContent())
	}
}

func cerbos_runtime_v1_RuleTable_Manifest_hashpb_sum(m *RuleTable_Manifest, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.RuleTable.Manifest.bundle_id"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetBundleId()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetBundleId()), len(m.GetBundleId())))
	}
}

func cerbos_runtime_v1_RuleTable_PolicyDerivedRoles_hashpb_sum(m *RuleTable_PolicyDerivedRoles, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.RuleTable.PolicyDerivedRoles.derived_roles"]; !ok {
		if len(m.DerivedRoles) > 0 {
			if len(m.DerivedRoles) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.DerivedRoles {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.DerivedRoles[k] != nil {
						cerbos_runtime_v1_RunnableDerivedRole_hashpb_sum(m.DerivedRoles[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.DerivedRoles)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.DerivedRoles[k] != nil {
						cerbos_runtime_v1_RunnableDerivedRole_hashpb_sum(m.DerivedRoles[k], hasher, ignore, b)
					}
				}
			}
		}
	}
}

func cerbos_runtime_v1_RuleTable_RoleParentRoles_ParentRoles_hashpb_sum(m *RuleTable_RoleParentRoles_ParentRoles, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.RuleTable.RoleParentRoles.ParentRoles.roles"]; !ok {
		if len(m.Roles) > 0 {
			for _, v := range m.Roles {
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(v))))
				_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(v), len(v)))
			}
		}
	}
}

func cerbos_runtime_v1_RuleTable_RoleParentRoles_hashpb_sum(m *RuleTable_RoleParentRoles, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.RuleTable.RoleParentRoles.role_parent_roles"]; !ok {
		if len(m.RoleParentRoles) > 0 {
			if len(m.RoleParentRoles) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.RoleParentRoles {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.RoleParentRoles[k] != nil {
						cerbos_runtime_v1_RuleTable_RoleParentRoles_ParentRoles_hashpb_sum(m.RoleParentRoles[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.RoleParentRoles)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.RoleParentRoles[k] != nil {
						cerbos_runtime_v1_RuleTable_RoleParentRoles_ParentRoles_hashpb_sum(m.RoleParentRoles[k], hasher, ignore, b)
					}
				}
			}
		}
	}
}

func cerbos_runtime_v1_RuleTable_RuleRow_AllowActions_hashpb_sum(m *RuleTable_RuleRow_AllowActions, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.RuleTable.RuleRow.AllowActions.actions"]; !ok {
		if len(m.Actions) > 0 {
			if len(m.Actions) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.Actions {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Actions[k] != nil {
						google_protobuf_Empty_hashpb_sum(m.Actions[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.Actions)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Actions[k] != nil {
						google_protobuf_Empty_hashpb_sum(m.Actions[k], hasher, ignore, b)
					}
				}
			}
		}
	}
}

func cerbos_runtime_v1_RuleTable_RuleRow_Params_hashpb_sum(m *RuleTable_RuleRow_Params, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.RuleTable.RuleRow.Params.ordered_variables"]; !ok {
		if len(m.OrderedVariables) > 0 {
			for _, v := range m.OrderedVariables {
				if v != nil {
					cerbos_runtime_v1_Variable_hashpb_sum(v, hasher, ignore, b)
				}
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RuleTable.RuleRow.Params.constants"]; !ok {
		if len(m.Constants) > 0 {
			if len(m.Constants) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.Constants {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Constants[k] != nil {
						google_protobuf_Value_hashpb_sum(m.Constants[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.Constants)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Constants[k] != nil {
						google_protobuf_Value_hashpb_sum(m.Constants[k], hasher, ignore, b)
					}
				}
			}
		}
	}
}

func cerbos_runtime_v1_RuleTable_RuleRow_hashpb_sum(m *RuleTable_RuleRow, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.RuleTable.RuleRow.origin_fqn"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetOriginFqn()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetOriginFqn()), len(m.GetOriginFqn())))
	}
	if _, ok := ignore["cerbos.runtime.v1.RuleTable.RuleRow.resource"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetResource()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetResource()), len(m.GetResource())))
	}
	if _, ok := ignore["cerbos.runtime.v1.RuleTable.RuleRow.role"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetRole()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetRole()), len(m.GetRole())))
	}
	if m.ActionSet != nil {
		if _, ok := ignore["cerbos.runtime.v1.RuleTable.RuleRow.action_set"]; !ok {
			switch t := m.ActionSet.(type) {
			case *RuleTable_RuleRow_Action:
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(t.Action))))
				_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(t.Action), len(t.Action)))
			case *RuleTable_RuleRow_AllowActions_:
				if t.AllowActions != nil {
					cerbos_runtime_v1_RuleTable_RuleRow_AllowActions_hashpb_sum(t.AllowActions, hasher, ignore, b)
				}
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RuleTable.RuleRow.condition"]; !ok {
		if m.GetCondition() != nil {
			cerbos_runtime_v1_Condition_hashpb_sum(m.GetCondition(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RuleTable.RuleRow.derived_role_condition"]; !ok {
		if m.GetDerivedRoleCondition() != nil {
			cerbos_runtime_v1_Condition_hashpb_sum(m.GetDerivedRoleCondition(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RuleTable.RuleRow.effect"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(m.GetEffect())))
	}
	if _, ok := ignore["cerbos.runtime.v1.RuleTable.RuleRow.scope"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetScope()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetScope()), len(m.GetScope())))
	}
	if _, ok := ignore["cerbos.runtime.v1.RuleTable.RuleRow.scope_permissions"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(m.GetScopePermissions())))
	}
	if _, ok := ignore["cerbos.runtime.v1.RuleTable.RuleRow.version"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetVersion()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetVersion()), len(m.GetVersion())))
	}
	if _, ok := ignore["cerbos.runtime.v1.RuleTable.RuleRow.origin_derived_role"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetOriginDerivedRole()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetOriginDerivedRole()), len(m.GetOriginDerivedRole())))
	}
	if _, ok := ignore["cerbos.runtime.v1.RuleTable.RuleRow.emit_output"]; !ok {
		if m.GetEmitOutput() != nil {
			cerbos_runtime_v1_Output_hashpb_sum(m.GetEmitOutput(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RuleTable.RuleRow.name"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetName()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetName()), len(m.GetName())))
	}
	if _, ok := ignore["cerbos.runtime.v1.RuleTable.RuleRow.principal"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetPrincipal()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetPrincipal()), len(m.GetPrincipal())))
	}
	if _, ok := ignore["cerbos.runtime.v1.RuleTable.RuleRow.params"]; !ok {
		if m.GetParams() != nil {
			cerbos_runtime_v1_RuleTable_RuleRow_Params_hashpb_sum(m.GetParams(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RuleTable.RuleRow.derived_role_params"]; !ok {
		if m.GetDerivedRoleParams() != nil {
			cerbos_runtime_v1_RuleTable_RuleRow_Params_hashpb_sum(m.GetDerivedRoleParams(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RuleTable.RuleRow.evaluation_key"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetEvaluationKey()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetEvaluationKey()), len(m.GetEvaluationKey())))
	}
	if _, ok := ignore["cerbos.runtime.v1.RuleTable.RuleRow.policy_kind"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(m.GetPolicyKind())))
	}
	if _, ok := ignore["cerbos.runtime.v1.RuleTable.RuleRow.from_role_policy"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], protowire.EncodeBool(m.GetFromRolePolicy())))
	}
}

func cerbos_runtime_v1_RuleTable_hashpb_sum(m *RuleTable, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.RuleTable.rules"]; !ok {
		if len(m.Rules) > 0 {
			for _, v := range m.Rules {
				if v != nil {
					cerbos_runtime_v1_RuleTable_RuleRow_hashpb_sum(v, hasher, ignore, b)
				}
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RuleTable.schemas"]; !ok {
		if len(m.Schemas) > 0 {
			if len(m.Schemas) <= 32 {
				keys := hashpb_uint64KeyPool.Get().([]uint64)[:0]
				for k := range m.Schemas {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], k))
					if m.Schemas[k] != nil {
						cerbos_policy_v1_Schemas_hashpb_sum(m.Schemas[k], hasher, ignore, b)
					}
				}
				hashpb_uint64KeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.Schemas)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], k))
					if m.Schemas[k] != nil {
						cerbos_policy_v1_Schemas_hashpb_sum(m.Schemas[k], hasher, ignore, b)
					}
				}
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RuleTable.meta"]; !ok {
		if len(m.Meta) > 0 {
			if len(m.Meta) <= 32 {
				keys := hashpb_uint64KeyPool.Get().([]uint64)[:0]
				for k := range m.Meta {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], k))
					if m.Meta[k] != nil {
						cerbos_runtime_v1_RuleTableMetadata_hashpb_sum(m.Meta[k], hasher, ignore, b)
					}
				}
				hashpb_uint64KeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.Meta)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], k))
					if m.Meta[k] != nil {
						cerbos_runtime_v1_RuleTableMetadata_hashpb_sum(m.Meta[k], hasher, ignore, b)
					}
				}
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RuleTable.scope_parent_roles"]; !ok {
		if len(m.ScopeParentRoles) > 0 {
			if len(m.ScopeParentRoles) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.ScopeParentRoles {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.ScopeParentRoles[k] != nil {
						cerbos_runtime_v1_RuleTable_RoleParentRoles_hashpb_sum(m.ScopeParentRoles[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.ScopeParentRoles)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.ScopeParentRoles[k] != nil {
						cerbos_runtime_v1_RuleTable_RoleParentRoles_hashpb_sum(m.ScopeParentRoles[k], hasher, ignore, b)
					}
				}
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RuleTable.policy_derived_roles"]; !ok {
		if len(m.PolicyDerivedRoles) > 0 {
			if len(m.PolicyDerivedRoles) <= 32 {
				keys := hashpb_uint64KeyPool.Get().([]uint64)[:0]
				for k := range m.PolicyDerivedRoles {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], k))
					if m.PolicyDerivedRoles[k] != nil {
						cerbos_runtime_v1_RuleTable_PolicyDerivedRoles_hashpb_sum(m.PolicyDerivedRoles[k], hasher, ignore, b)
					}
				}
				hashpb_uint64KeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.PolicyDerivedRoles)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], k))
					if m.PolicyDerivedRoles[k] != nil {
						cerbos_runtime_v1_RuleTable_PolicyDerivedRoles_hashpb_sum(m.PolicyDerivedRoles[k], hasher, ignore, b)
					}
				}
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RuleTable.json_schemas"]; !ok {
		if len(m.JsonSchemas) > 0 {
			if len(m.JsonSchemas) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.JsonSchemas {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.JsonSchemas[k] != nil {
						cerbos_runtime_v1_RuleTable_JSONSchema_hashpb_sum(m.JsonSchemas[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.JsonSchemas)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.JsonSchemas[k] != nil {
						cerbos_runtime_v1_RuleTable_JSONSchema_hashpb_sum(m.JsonSchemas[k], hasher, ignore, b)
					}
				}
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RuleTable.manifest"]; !ok {
		if m.GetManifest() != nil {
			cerbos_runtime_v1_RuleTable_Manifest_hashpb_sum(m.GetManifest(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RuleTable.compiler_version"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(m.GetCompilerVersion())))
	}
}

func cerbos_runtime_v1_RunnableDerivedRole_hashpb_sum(m *RunnableDerivedRole, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.RunnableDerivedRole.name"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetName()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetName()), len(m.GetName())))
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableDerivedRole.parent_roles"]; !ok {
		if len(m.ParentRoles) > 0 {
			if len(m.ParentRoles) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.ParentRoles {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.ParentRoles[k] != nil {
						google_protobuf_Empty_hashpb_sum(m.ParentRoles[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.ParentRoles)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.ParentRoles[k] != nil {
						google_protobuf_Empty_hashpb_sum(m.ParentRoles[k], hasher, ignore, b)
					}
				}
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableDerivedRole.variables"]; !ok {
		if len(m.Variables) > 0 {
			if len(m.Variables) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.Variables {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Variables[k] != nil {
						cerbos_runtime_v1_Expr_hashpb_sum(m.Variables[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.Variables)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Variables[k] != nil {
						cerbos_runtime_v1_Expr_hashpb_sum(m.Variables[k], hasher, ignore, b)
					}
				}
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableDerivedRole.condition"]; !ok {
		if m.GetCondition() != nil {
			cerbos_runtime_v1_Condition_hashpb_sum(m.GetCondition(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableDerivedRole.ordered_variables"]; !ok {
		if len(m.OrderedVariables) > 0 {
			for _, v := range m.OrderedVariables {
				if v != nil {
					cerbos_runtime_v1_Variable_hashpb_sum(v, hasher, ignore, b)
				}
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableDerivedRole.constants"]; !ok {
		if len(m.Constants) > 0 {
			if len(m.Constants) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.Constants {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Constants[k] != nil {
						google_protobuf_Value_hashpb_sum(m.Constants[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.Constants)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Constants[k] != nil {
						google_protobuf_Value_hashpb_sum(m.Constants[k], hasher, ignore, b)
					}
				}
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableDerivedRole.origin_fqn"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetOriginFqn()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetOriginFqn()), len(m.GetOriginFqn())))
	}
}

func cerbos_runtime_v1_RunnableDerivedRolesSet_Metadata_hashpb_sum(m *RunnableDerivedRolesSet_Metadata, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.RunnableDerivedRolesSet.Metadata.fqn"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetFqn()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetFqn()), len(m.GetFqn())))
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableDerivedRolesSet.Metadata.annotations"]; !ok {
		if len(m.Annotations) > 0 {
			if len(m.Annotations) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.Annotations {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.Annotations[k]))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.Annotations[k]), len(m.Annotations[k])))
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.Annotations)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.Annotations[k]))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.Annotations[k]), len(m.Annotations[k])))
				}
			}
		}
	}
}

func cerbos_runtime_v1_RunnableDerivedRolesSet_hashpb_sum(m *RunnableDerivedRolesSet, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.RunnableDerivedRolesSet.meta"]; !ok {
		if m.GetMeta() != nil {
			cerbos_runtime_v1_RunnableDerivedRolesSet_Metadata_hashpb_sum(m.GetMeta(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableDerivedRolesSet.derived_roles"]; !ok {
		if len(m.DerivedRoles) > 0 {
			if len(m.DerivedRoles) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.DerivedRoles {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.DerivedRoles[k] != nil {
						cerbos_runtime_v1_RunnableDerivedRole_hashpb_sum(m.DerivedRoles[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.DerivedRoles)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.DerivedRoles[k] != nil {
						cerbos_runtime_v1_RunnableDerivedRole_hashpb_sum(m.DerivedRoles[k], hasher, ignore, b)
					}
				}
			}
		}
	}
}

func cerbos_runtime_v1_RunnablePolicySet_hashpb_sum(m *RunnablePolicySet, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.RunnablePolicySet.fqn"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetFqn()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetFqn()), len(m.GetFqn())))
	}
	if m.PolicySet != nil {
		if _, ok := ignore["cerbos.runtime.v1.RunnablePolicySet.policy_set"]; !ok {
			switch t := m.PolicySet.(type) {
			case *RunnablePolicySet_ResourcePolicy:
				if t.ResourcePolicy != nil {
					cerbos_runtime_v1_RunnableResourcePolicySet_hashpb_sum(t.ResourcePolicy, hasher, ignore, b)
				}
			case *RunnablePolicySet_PrincipalPolicy:
				if t.PrincipalPolicy != nil {
					cerbos_runtime_v1_RunnablePrincipalPolicySet_hashpb_sum(t.PrincipalPolicy, hasher, ignore, b)
				}
			case *RunnablePolicySet_DerivedRoles:
				if t.DerivedRoles != nil {
					cerbos_runtime_v1_RunnableDerivedRolesSet_hashpb_sum(t.DerivedRoles, hasher, ignore, b)
				}
			case *RunnablePolicySet_Variables:
				if t.Variables != nil {
					cerbos_runtime_v1_RunnableVariablesSet_hashpb_sum(t.Variables, hasher, ignore, b)
				}
			case *RunnablePolicySet_RolePolicy:
				if t.RolePolicy != nil {
					cerbos_runtime_v1_RunnableRolePolicySet_hashpb_sum(t.RolePolicy, hasher, ignore, b)
				}
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnablePolicySet.compiler_version"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(m.GetCompilerVersion())))
	}
}

func cerbos_runtime_v1_RunnablePrincipalPolicySet_Metadata_hashpb_sum(m *RunnablePrincipalPolicySet_Metadata, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.RunnablePrincipalPolicySet.Metadata.fqn"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetFqn()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetFqn()), len(m.GetFqn())))
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnablePrincipalPolicySet.Metadata.principal"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetPrincipal()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetPrincipal()), len(m.GetPrincipal())))
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnablePrincipalPolicySet.Metadata.version"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetVersion()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetVersion()), len(m.GetVersion())))
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnablePrincipalPolicySet.Metadata.source_attributes"]; !ok {
		if len(m.SourceAttributes) > 0 {
			if len(m.SourceAttributes) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.SourceAttributes {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.SourceAttributes[k] != nil {
						cerbos_policy_v1_SourceAttributes_hashpb_sum(m.SourceAttributes[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.SourceAttributes)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.SourceAttributes[k] != nil {
						cerbos_policy_v1_SourceAttributes_hashpb_sum(m.SourceAttributes[k], hasher, ignore, b)
					}
				}
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnablePrincipalPolicySet.Metadata.annotations"]; !ok {
		if len(m.Annotations) > 0 {
			if len(m.Annotations) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.Annotations {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.Annotations[k]))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.Annotations[k]), len(m.Annotations[k])))
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.Annotations)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.Annotations[k]))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.Annotations[k]), len(m.Annotations[k])))
				}
			}
		}
	}
}

func cerbos_runtime_v1_RunnablePrincipalPolicySet_Policy_ActionRule_hashpb_sum(m *RunnablePrincipalPolicySet_Policy_ActionRule, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.RunnablePrincipalPolicySet.Policy.ActionRule.action"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetAction()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetAction()), len(m.GetAction())))
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnablePrincipalPolicySet.Policy.ActionRule.name"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetName()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetName()), len(m.GetName())))
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnablePrincipalPolicySet.Policy.ActionRule.condition"]; !ok {
		if m.GetCondition() != nil {
			cerbos_runtime_v1_Condition_hashpb_sum(m.GetCondition(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnablePrincipalPolicySet.Policy.ActionRule.effect"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(m.GetEffect())))
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnablePrincipalPolicySet.Policy.ActionRule.output"]; !ok {
		if m.GetOutput() != nil {
			cerbos_runtime_v1_Expr_hashpb_sum(m.GetOutput(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnablePrincipalPolicySet.Policy.ActionRule.emit_output"]; !ok {
		if m.GetEmitOutput() != nil {
			cerbos_runtime_v1_Output_hashpb_sum(m.GetEmitOutput(), hasher, ignore, b)
		}
	}
}

func cerbos_runtime_v1_RunnablePrincipalPolicySet_Policy_ResourceRules_hashpb_sum(m *RunnablePrincipalPolicySet_Policy_ResourceRules, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.RunnablePrincipalPolicySet.Policy.ResourceRules.action_rules"]; !ok {
		if len(m.ActionRules) > 0 {
			for _, v := range m.ActionRules {
				if v != nil {
					cerbos_runtime_v1_RunnablePrincipalPolicySet_Policy_ActionRule_hashpb_sum(v, hasher, ignore, b)
				}
			}
		}
	}
}

func cerbos_runtime_v1_RunnablePrincipalPolicySet_Policy_hashpb_sum(m *RunnablePrincipalPolicySet_Policy, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.RunnablePrincipalPolicySet.Policy.scope"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetScope()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetScope()), len(m.GetScope())))
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnablePrincipalPolicySet.Policy.variables"]; !ok {
		if len(m.Variables) > 0 {
			if len(m.Variables) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.Variables {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Variables[k] != nil {
						cerbos_runtime_v1_Expr_hashpb_sum(m.Variables[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.Variables)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Variables[k] != nil {
						cerbos_runtime_v1_Expr_hashpb_sum(m.Variables[k], hasher, ignore, b)
					}
				}
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnablePrincipalPolicySet.Policy.resource_rules"]; !ok {
		if len(m.ResourceRules) > 0 {
			if len(m.ResourceRules) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.ResourceRules {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.ResourceRules[k] != nil {
						cerbos_runtime_v1_RunnablePrincipalPolicySet_Policy_ResourceRules_hashpb_sum(m.ResourceRules[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.ResourceRules)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.ResourceRules[k] != nil {
						cerbos_runtime_v1_RunnablePrincipalPolicySet_Policy_ResourceRules_hashpb_sum(m.ResourceRules[k], hasher, ignore, b)
					}
				}
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnablePrincipalPolicySet.Policy.ordered_variables"]; !ok {
		if len(m.OrderedVariables) > 0 {
			for _, v := range m.OrderedVariables {
				if v != nil {
					cerbos_runtime_v1_Variable_hashpb_sum(v, hasher, ignore, b)
				}
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnablePrincipalPolicySet.Policy.scope_permissions"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(m.GetScopePermissions())))
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnablePrincipalPolicySet.Policy.constants"]; !ok {
		if len(m.Constants) > 0 {
			if len(m.Constants) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.Constants {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Constants[k] != nil {
						google_protobuf_Value_hashpb_sum(m.Constants[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.Constants)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Constants[k] != nil {
						google_protobuf_Value_hashpb_sum(m.Constants[k], hasher, ignore, b)
					}
				}
			}
		}
	}
}

func cerbos_runtime_v1_RunnablePrincipalPolicySet_hashpb_sum(m *RunnablePrincipalPolicySet, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.RunnablePrincipalPolicySet.meta"]; !ok {
		if m.GetMeta() != nil {
			cerbos_runtime_v1_RunnablePrincipalPolicySet_Metadata_hashpb_sum(m.GetMeta(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnablePrincipalPolicySet.policies"]; !ok {
		if len(m.Policies) > 0 {
			for _, v := range m.Policies {
				if v != nil {
					cerbos_runtime_v1_RunnablePrincipalPolicySet_Policy_hashpb_sum(v, hasher, ignore, b)
				}
			}
		}
	}
}

func cerbos_runtime_v1_RunnableResourcePolicySet_Metadata_hashpb_sum(m *RunnableResourcePolicySet_Metadata, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.RunnableResourcePolicySet.Metadata.fqn"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetFqn()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetFqn()), len(m.GetFqn())))
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableResourcePolicySet.Metadata.resource"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetResource()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetResource()), len(m.GetResource())))
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableResourcePolicySet.Metadata.version"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetVersion()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetVersion()), len(m.GetVersion())))
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableResourcePolicySet.Metadata.source_attributes"]; !ok {
		if len(m.SourceAttributes) > 0 {
			if len(m.SourceAttributes) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.SourceAttributes {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.SourceAttributes[k] != nil {
						cerbos_policy_v1_SourceAttributes_hashpb_sum(m.SourceAttributes[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.SourceAttributes)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.SourceAttributes[k] != nil {
						cerbos_policy_v1_SourceAttributes_hashpb_sum(m.SourceAttributes[k], hasher, ignore, b)
					}
				}
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableResourcePolicySet.Metadata.annotations"]; !ok {
		if len(m.Annotations) > 0 {
			if len(m.Annotations) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.Annotations {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.Annotations[k]))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.Annotations[k]), len(m.Annotations[k])))
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.Annotations)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.Annotations[k]))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.Annotations[k]), len(m.Annotations[k])))
				}
			}
		}
	}
}

func cerbos_runtime_v1_RunnableResourcePolicySet_Policy_Rule_hashpb_sum(m *RunnableResourcePolicySet_Policy_Rule, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.RunnableResourcePolicySet.Policy.Rule.name"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetName()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetName()), len(m.GetName())))
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableResourcePolicySet.Policy.Rule.actions"]; !ok {
		if len(m.Actions) > 0 {
			if len(m.Actions) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.Actions {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Actions[k] != nil {
						google_protobuf_Empty_hashpb_sum(m.Actions[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.Actions)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Actions[k] != nil {
						google_protobuf_Empty_hashpb_sum(m.Actions[k], hasher, ignore, b)
					}
				}
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableResourcePolicySet.Policy.Rule.derived_roles"]; !ok {
		if len(m.DerivedRoles) > 0 {
			if len(m.DerivedRoles) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.DerivedRoles {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.DerivedRoles[k] != nil {
						google_protobuf_Empty_hashpb_sum(m.DerivedRoles[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.DerivedRoles)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.DerivedRoles[k] != nil {
						google_protobuf_Empty_hashpb_sum(m.DerivedRoles[k], hasher, ignore, b)
					}
				}
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableResourcePolicySet.Policy.Rule.roles"]; !ok {
		if len(m.Roles) > 0 {
			if len(m.Roles) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.Roles {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Roles[k] != nil {
						google_protobuf_Empty_hashpb_sum(m.Roles[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.Roles)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Roles[k] != nil {
						google_protobuf_Empty_hashpb_sum(m.Roles[k], hasher, ignore, b)
					}
				}
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableResourcePolicySet.Policy.Rule.condition"]; !ok {
		if m.GetCondition() != nil {
			cerbos_runtime_v1_Condition_hashpb_sum(m.GetCondition(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableResourcePolicySet.Policy.Rule.effect"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(m.GetEffect())))
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableResourcePolicySet.Policy.Rule.output"]; !ok {
		if m.GetOutput() != nil {
			cerbos_runtime_v1_Expr_hashpb_sum(m.GetOutput(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableResourcePolicySet.Policy.Rule.emit_output"]; !ok {
		if m.GetEmitOutput() != nil {
			cerbos_runtime_v1_Output_hashpb_sum(m.GetEmitOutput(), hasher, ignore, b)
		}
	}
}

func cerbos_runtime_v1_RunnableResourcePolicySet_Policy_hashpb_sum(m *RunnableResourcePolicySet_Policy, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.RunnableResourcePolicySet.Policy.scope"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetScope()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetScope()), len(m.GetScope())))
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableResourcePolicySet.Policy.derived_roles"]; !ok {
		if len(m.DerivedRoles) > 0 {
			if len(m.DerivedRoles) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.DerivedRoles {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.DerivedRoles[k] != nil {
						cerbos_runtime_v1_RunnableDerivedRole_hashpb_sum(m.DerivedRoles[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.DerivedRoles)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.DerivedRoles[k] != nil {
						cerbos_runtime_v1_RunnableDerivedRole_hashpb_sum(m.DerivedRoles[k], hasher, ignore, b)
					}
				}
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableResourcePolicySet.Policy.variables"]; !ok {
		if len(m.Variables) > 0 {
			if len(m.Variables) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.Variables {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Variables[k] != nil {
						cerbos_runtime_v1_Expr_hashpb_sum(m.Variables[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.Variables)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Variables[k] != nil {
						cerbos_runtime_v1_Expr_hashpb_sum(m.Variables[k], hasher, ignore, b)
					}
				}
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableResourcePolicySet.Policy.rules"]; !ok {
		if len(m.Rules) > 0 {
			for _, v := range m.Rules {
				if v != nil {
					cerbos_runtime_v1_RunnableResourcePolicySet_Policy_Rule_hashpb_sum(v, hasher, ignore, b)
				}
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableResourcePolicySet.Policy.schemas"]; !ok {
		if m.GetSchemas() != nil {
			cerbos_policy_v1_Schemas_hashpb_sum(m.GetSchemas(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableResourcePolicySet.Policy.ordered_variables"]; !ok {
		if len(m.OrderedVariables) > 0 {
			for _, v := range m.OrderedVariables {
				if v != nil {
					cerbos_runtime_v1_Variable_hashpb_sum(v, hasher, ignore, b)
				}
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableResourcePolicySet.Policy.scope_permissions"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(m.GetScopePermissions())))
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableResourcePolicySet.Policy.constants"]; !ok {
		if len(m.Constants) > 0 {
			if len(m.Constants) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.Constants {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Constants[k] != nil {
						google_protobuf_Value_hashpb_sum(m.Constants[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.Constants)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Constants[k] != nil {
						google_protobuf_Value_hashpb_sum(m.Constants[k], hasher, ignore, b)
					}
				}
			}
		}
	}
}

func cerbos_runtime_v1_RunnableResourcePolicySet_hashpb_sum(m *RunnableResourcePolicySet, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.RunnableResourcePolicySet.meta"]; !ok {
		if m.GetMeta() != nil {
			cerbos_runtime_v1_RunnableResourcePolicySet_Metadata_hashpb_sum(m.GetMeta(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableResourcePolicySet.policies"]; !ok {
		if len(m.Policies) > 0 {
			for _, v := range m.Policies {
				if v != nil {
					cerbos_runtime_v1_RunnableResourcePolicySet_Policy_hashpb_sum(v, hasher, ignore, b)
				}
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableResourcePolicySet.schemas"]; !ok {
		if m.GetSchemas() != nil {
			cerbos_policy_v1_Schemas_hashpb_sum(m.GetSchemas(), hasher, ignore, b)
		}
	}
}

func cerbos_runtime_v1_RunnableRolePolicySet_Metadata_hashpb_sum(m *RunnableRolePolicySet_Metadata, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.RunnableRolePolicySet.Metadata.fqn"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetFqn()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetFqn()), len(m.GetFqn())))
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableRolePolicySet.Metadata.source_attributes"]; !ok {
		if len(m.SourceAttributes) > 0 {
			if len(m.SourceAttributes) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.SourceAttributes {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.SourceAttributes[k] != nil {
						cerbos_policy_v1_SourceAttributes_hashpb_sum(m.SourceAttributes[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.SourceAttributes)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.SourceAttributes[k] != nil {
						cerbos_policy_v1_SourceAttributes_hashpb_sum(m.SourceAttributes[k], hasher, ignore, b)
					}
				}
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableRolePolicySet.Metadata.annotations"]; !ok {
		if len(m.Annotations) > 0 {
			if len(m.Annotations) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.Annotations {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.Annotations[k]))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.Annotations[k]), len(m.Annotations[k])))
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.Annotations)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.Annotations[k]))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.Annotations[k]), len(m.Annotations[k])))
				}
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableRolePolicySet.Metadata.version"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetVersion()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetVersion()), len(m.GetVersion())))
	}
}

func cerbos_runtime_v1_RunnableRolePolicySet_RuleList_hashpb_sum(m *RunnableRolePolicySet_RuleList, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.RunnableRolePolicySet.RuleList.rules"]; !ok {
		if len(m.Rules) > 0 {
			for _, v := range m.Rules {
				if v != nil {
					cerbos_runtime_v1_RunnableRolePolicySet_Rule_hashpb_sum(v, hasher, ignore, b)
				}
			}
		}
	}
}

func cerbos_runtime_v1_RunnableRolePolicySet_Rule_hashpb_sum(m *RunnableRolePolicySet_Rule, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.RunnableRolePolicySet.Rule.resource"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetResource()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetResource()), len(m.GetResource())))
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableRolePolicySet.Rule.allow_actions"]; !ok {
		if len(m.AllowActions) > 0 {
			if len(m.AllowActions) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.AllowActions {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.AllowActions[k] != nil {
						google_protobuf_Empty_hashpb_sum(m.AllowActions[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.AllowActions)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.AllowActions[k] != nil {
						google_protobuf_Empty_hashpb_sum(m.AllowActions[k], hasher, ignore, b)
					}
				}
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableRolePolicySet.Rule.condition"]; !ok {
		if m.GetCondition() != nil {
			cerbos_runtime_v1_Condition_hashpb_sum(m.GetCondition(), hasher, ignore, b)
		}
	}
}

func cerbos_runtime_v1_RunnableRolePolicySet_hashpb_sum(m *RunnableRolePolicySet, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.RunnableRolePolicySet.meta"]; !ok {
		if m.GetMeta() != nil {
			cerbos_runtime_v1_RunnableRolePolicySet_Metadata_hashpb_sum(m.GetMeta(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableRolePolicySet.role"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetRole()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetRole()), len(m.GetRole())))
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableRolePolicySet.scope"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetScope()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetScope()), len(m.GetScope())))
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableRolePolicySet.scope_permissions"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(m.GetScopePermissions())))
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableRolePolicySet.parent_roles"]; !ok {
		if len(m.ParentRoles) > 0 {
			for _, v := range m.ParentRoles {
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(v))))
				_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(v), len(v)))
			}
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableRolePolicySet.resources"]; !ok {
		if len(m.Resources) > 0 {
			if len(m.Resources) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.Resources {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Resources[k] != nil {
						cerbos_runtime_v1_RunnableRolePolicySet_RuleList_hashpb_sum(m.Resources[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.Resources)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Resources[k] != nil {
						cerbos_runtime_v1_RunnableRolePolicySet_RuleList_hashpb_sum(m.Resources[k], hasher, ignore, b)
					}
				}
			}
		}
	}
}

func cerbos_runtime_v1_RunnableVariablesSet_Metadata_hashpb_sum(m *RunnableVariablesSet_Metadata, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.RunnableVariablesSet.Metadata.fqn"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetFqn()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetFqn()), len(m.GetFqn())))
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableVariablesSet.Metadata.annotations"]; !ok {
		if len(m.Annotations) > 0 {
			if len(m.Annotations) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.Annotations {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.Annotations[k]))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.Annotations[k]), len(m.Annotations[k])))
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.Annotations)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.Annotations[k]))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.Annotations[k]), len(m.Annotations[k])))
				}
			}
		}
	}
}

func cerbos_runtime_v1_RunnableVariablesSet_hashpb_sum(m *RunnableVariablesSet, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.RunnableVariablesSet.meta"]; !ok {
		if m.GetMeta() != nil {
			cerbos_runtime_v1_RunnableVariablesSet_Metadata_hashpb_sum(m.GetMeta(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["cerbos.runtime.v1.RunnableVariablesSet.variables"]; !ok {
		if len(m.Variables) > 0 {
			if len(m.Variables) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.Variables {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Variables[k] != nil {
						cerbos_runtime_v1_Expr_hashpb_sum(m.Variables[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.Variables)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Variables[k] != nil {
						cerbos_runtime_v1_Expr_hashpb_sum(m.Variables[k], hasher, ignore, b)
					}
				}
			}
		}
	}
}

func cerbos_runtime_v1_Variable_hashpb_sum(m *Variable, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.runtime.v1.Variable.name"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetName()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetName()), len(m.GetName())))
	}
	if _, ok := ignore["cerbos.runtime.v1.Variable.expr"]; !ok {
		if m.GetExpr() != nil {
			cerbos_runtime_v1_Expr_hashpb_sum(m.GetExpr(), hasher, ignore, b)
		}
	}
}

func cerbos_source_v1_Error_hashpb_sum(m *v11.Error, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.source.v1.Error.kind"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(m.GetKind())))
	}
	if _, ok := ignore["cerbos.source.v1.Error.position"]; !ok {
		if m.GetPosition() != nil {
			cerbos_source_v1_Position_hashpb_sum(m.GetPosition(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["cerbos.source.v1.Error.message"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetMessage()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetMessage()), len(m.GetMessage())))
	}
	if _, ok := ignore["cerbos.source.v1.Error.context"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetContext()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetContext()), len(m.GetContext())))
	}
}

func cerbos_source_v1_Position_hashpb_sum(m *v11.Position, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["cerbos.source.v1.Position.line"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(m.GetLine())))
	}
	if _, ok := ignore["cerbos.source.v1.Position.column"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(m.GetColumn())))
	}
	if _, ok := ignore["cerbos.source.v1.Position.path"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetPath()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetPath()), len(m.GetPath())))
	}
}

func google_api_expr_v1alpha1_CheckedExpr_hashpb_sum(m *v1alpha1.CheckedExpr, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["google.api.expr.v1alpha1.CheckedExpr.reference_map"]; !ok {
		if len(m.ReferenceMap) > 0 {
			if len(m.ReferenceMap) <= 32 {
				keys := hashpb_int64KeyPool.Get().([]int64)[:0]
				for k := range m.ReferenceMap {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(k)))
					if m.ReferenceMap[k] != nil {
						google_api_expr_v1alpha1_Reference_hashpb_sum(m.ReferenceMap[k], hasher, ignore, b)
					}
				}
				hashpb_int64KeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.ReferenceMap)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(k)))
					if m.ReferenceMap[k] != nil {
						google_api_expr_v1alpha1_Reference_hashpb_sum(m.ReferenceMap[k], hasher, ignore, b)
					}
				}
			}
		}
	}
	if _, ok := ignore["google.api.expr.v1alpha1.CheckedExpr.type_map"]; !ok {
		if len(m.TypeMap) > 0 {
			if len(m.TypeMap) <= 32 {
				keys := hashpb_int64KeyPool.Get().([]int64)[:0]
				for k := range m.TypeMap {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(k)))
					if m.TypeMap[k] != nil {
						google_api_expr_v1alpha1_Type_hashpb_sum(m.TypeMap[k], hasher, ignore, b)
					}
				}
				hashpb_int64KeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.TypeMap)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(k)))
					if m.TypeMap[k] != nil {
						google_api_expr_v1alpha1_Type_hashpb_sum(m.TypeMap[k], hasher, ignore, b)
					}
				}
			}
		}
	}
	if _, ok := ignore["google.api.expr.v1alpha1.CheckedExpr.expr"]; !ok {
		if m.GetExpr() != nil {
			google_api_expr_v1alpha1_Expr_hashpb_sum(m.GetExpr(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["google.api.expr.v1alpha1.CheckedExpr.source_info"]; !ok {
		if m.GetSourceInfo() != nil {
			google_api_expr_v1alpha1_SourceInfo_hashpb_sum(m.GetSourceInfo(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["google.api.expr.v1alpha1.CheckedExpr.expr_version"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetExprVersion()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetExprVersion()), len(m.GetExprVersion())))
	}
}

func google_api_expr_v1alpha1_Constant_hashpb_sum(m *v1alpha1.Constant, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if m.ConstantKind != nil {
		if _, ok := ignore["google.api.expr.v1alpha1.Constant.constant_kind"]; !ok {
			switch t := m.ConstantKind.(type) {
			case *v1alpha1.Constant_NullValue:
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(t.NullValue)))
			case *v1alpha1.Constant_BoolValue:
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], protowire.EncodeBool(t.BoolValue)))
			case *v1alpha1.Constant_Int64Value:
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(t.Int64Value)))
			case *v1alpha1.Constant_Uint64Value:
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], t.Uint64Value))
			case *v1alpha1.Constant_DoubleValue:
				_, _ = hasher.Write(protowire.AppendFixed64(b[:0], math.Float64bits(t.DoubleValue)))
			case *v1alpha1.Constant_StringValue:
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(t.StringValue))))
				_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(t.StringValue), len(t.StringValue)))
			case *v1alpha1.Constant_BytesValue:
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(t.BytesValue))))
				_, _ = hasher.Write(t.BytesValue)
			case *v1alpha1.Constant_DurationValue:
				if t.DurationValue != nil {
					google_protobuf_Duration_hashpb_sum(t.DurationValue, hasher, ignore, b)
				}
			case *v1alpha1.Constant_TimestampValue:
				if t.TimestampValue != nil {
					google_protobuf_Timestamp_hashpb_sum(t.TimestampValue, hasher, ignore, b)
				}
			}
		}
	}
}

func google_api_expr_v1alpha1_Expr_Call_hashpb_sum(m *v1alpha1.Expr_Call, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["google.api.expr.v1alpha1.Expr.Call.target"]; !ok {
		if m.GetTarget() != nil {
			google_api_expr_v1alpha1_Expr_hashpb_sum(m.GetTarget(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["google.api.expr.v1alpha1.Expr.Call.function"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetFunction()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetFunction()), len(m.GetFunction())))
	}
	if _, ok := ignore["google.api.expr.v1alpha1.Expr.Call.args"]; !ok {
		if len(m.Args) > 0 {
			for _, v := range m.Args {
				if v != nil {
					google_api_expr_v1alpha1_Expr_hashpb_sum(v, hasher, ignore, b)
				}
			}
		}
	}
}

func google_api_expr_v1alpha1_Expr_Comprehension_hashpb_sum(m *v1alpha1.Expr_Comprehension, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["google.api.expr.v1alpha1.Expr.Comprehension.iter_var"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetIterVar()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetIterVar()), len(m.GetIterVar())))
	}
	if _, ok := ignore["google.api.expr.v1alpha1.Expr.Comprehension.iter_range"]; !ok {
		if m.GetIterRange() != nil {
			google_api_expr_v1alpha1_Expr_hashpb_sum(m.GetIterRange(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["google.api.expr.v1alpha1.Expr.Comprehension.accu_var"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetAccuVar()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetAccuVar()), len(m.GetAccuVar())))
	}
	if _, ok := ignore["google.api.expr.v1alpha1.Expr.Comprehension.accu_init"]; !ok {
		if m.GetAccuInit() != nil {
			google_api_expr_v1alpha1_Expr_hashpb_sum(m.GetAccuInit(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["google.api.expr.v1alpha1.Expr.Comprehension.loop_condition"]; !ok {
		if m.GetLoopCondition() != nil {
			google_api_expr_v1alpha1_Expr_hashpb_sum(m.GetLoopCondition(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["google.api.expr.v1alpha1.Expr.Comprehension.loop_step"]; !ok {
		if m.GetLoopStep() != nil {
			google_api_expr_v1alpha1_Expr_hashpb_sum(m.GetLoopStep(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["google.api.expr.v1alpha1.Expr.Comprehension.result"]; !ok {
		if m.GetResult() != nil {
			google_api_expr_v1alpha1_Expr_hashpb_sum(m.GetResult(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["google.api.expr.v1alpha1.Expr.Comprehension.iter_var2"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetIterVar2()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetIterVar2()), len(m.GetIterVar2())))
	}
}

func google_api_expr_v1alpha1_Expr_CreateList_hashpb_sum(m *v1alpha1.Expr_CreateList, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["google.api.expr.v1alpha1.Expr.CreateList.elements"]; !ok {
		if len(m.Elements) > 0 {
			for _, v := range m.Elements {
				if v != nil {
					google_api_expr_v1alpha1_Expr_hashpb_sum(v, hasher, ignore, b)
				}
			}
		}
	}
	if _, ok := ignore["google.api.expr.v1alpha1.Expr.CreateList.optional_indices"]; !ok {
		if len(m.OptionalIndices) > 0 {
			for _, v := range m.OptionalIndices {
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(v)))
			}
		}
	}
}

func google_api_expr_v1alpha1_Expr_CreateStruct_Entry_hashpb_sum(m *v1alpha1.Expr_CreateStruct_Entry, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["google.api.expr.v1alpha1.Expr.CreateStruct.Entry.id"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(m.GetId())))
	}
	if m.KeyKind != nil {
		if _, ok := ignore["google.api.expr.v1alpha1.Expr.CreateStruct.Entry.key_kind"]; !ok {
			switch t := m.KeyKind.(type) {
			case *v1alpha1.Expr_CreateStruct_Entry_FieldKey:
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(t.FieldKey))))
				_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(t.FieldKey), len(t.FieldKey)))
			case *v1alpha1.Expr_CreateStruct_Entry_MapKey:
				if t.MapKey != nil {
					google_api_expr_v1alpha1_Expr_hashpb_sum(t.MapKey, hasher, ignore, b)
				}
			}
		}
	}
	if _, ok := ignore["google.api.expr.v1alpha1.Expr.CreateStruct.Entry.value"]; !ok {
		if m.GetValue() != nil {
			google_api_expr_v1alpha1_Expr_hashpb_sum(m.GetValue(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["google.api.expr.v1alpha1.Expr.CreateStruct.Entry.optional_entry"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], protowire.EncodeBool(m.GetOptionalEntry())))
	}
}

func google_api_expr_v1alpha1_Expr_CreateStruct_hashpb_sum(m *v1alpha1.Expr_CreateStruct, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["google.api.expr.v1alpha1.Expr.CreateStruct.message_name"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetMessageName()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetMessageName()), len(m.GetMessageName())))
	}
	if _, ok := ignore["google.api.expr.v1alpha1.Expr.CreateStruct.entries"]; !ok {
		if len(m.Entries) > 0 {
			for _, v := range m.Entries {
				if v != nil {
					google_api_expr_v1alpha1_Expr_CreateStruct_Entry_hashpb_sum(v, hasher, ignore, b)
				}
			}
		}
	}
}

func google_api_expr_v1alpha1_Expr_Ident_hashpb_sum(m *v1alpha1.Expr_Ident, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["google.api.expr.v1alpha1.Expr.Ident.name"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetName()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetName()), len(m.GetName())))
	}
}

func google_api_expr_v1alpha1_Expr_Select_hashpb_sum(m *v1alpha1.Expr_Select, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["google.api.expr.v1alpha1.Expr.Select.operand"]; !ok {
		if m.GetOperand() != nil {
			google_api_expr_v1alpha1_Expr_hashpb_sum(m.GetOperand(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["google.api.expr.v1alpha1.Expr.Select.field"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetField()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetField()), len(m.GetField())))
	}
	if _, ok := ignore["google.api.expr.v1alpha1.Expr.Select.test_only"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], protowire.EncodeBool(m.GetTestOnly())))
	}
}

func google_api_expr_v1alpha1_Expr_hashpb_sum(m *v1alpha1.Expr, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["google.api.expr.v1alpha1.Expr.id"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(m.GetId())))
	}
	if m.ExprKind != nil {
		if _, ok := ignore["google.api.expr.v1alpha1.Expr.expr_kind"]; !ok {
			switch t := m.ExprKind.(type) {
			case *v1alpha1.Expr_ConstExpr:
				if t.ConstExpr != nil {
					google_api_expr_v1alpha1_Constant_hashpb_sum(t.ConstExpr, hasher, ignore, b)
				}
			case *v1alpha1.Expr_IdentExpr:
				if t.IdentExpr != nil {
					google_api_expr_v1alpha1_Expr_Ident_hashpb_sum(t.IdentExpr, hasher, ignore, b)
				}
			case *v1alpha1.Expr_SelectExpr:
				if t.SelectExpr != nil {
					google_api_expr_v1alpha1_Expr_Select_hashpb_sum(t.SelectExpr, hasher, ignore, b)
				}
			case *v1alpha1.Expr_CallExpr:
				if t.CallExpr != nil {
					google_api_expr_v1alpha1_Expr_Call_hashpb_sum(t.CallExpr, hasher, ignore, b)
				}
			case *v1alpha1.Expr_ListExpr:
				if t.ListExpr != nil {
					google_api_expr_v1alpha1_Expr_CreateList_hashpb_sum(t.ListExpr, hasher, ignore, b)
				}
			case *v1alpha1.Expr_StructExpr:
				if t.StructExpr != nil {
					google_api_expr_v1alpha1_Expr_CreateStruct_hashpb_sum(t.StructExpr, hasher, ignore, b)
				}
			case *v1alpha1.Expr_ComprehensionExpr:
				if t.ComprehensionExpr != nil {
					google_api_expr_v1alpha1_Expr_Comprehension_hashpb_sum(t.ComprehensionExpr, hasher, ignore, b)
				}
			}
		}
	}
}

func google_api_expr_v1alpha1_Reference_hashpb_sum(m *v1alpha1.Reference, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["google.api.expr.v1alpha1.Reference.name"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetName()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetName()), len(m.GetName())))
	}
	if _, ok := ignore["google.api.expr.v1alpha1.Reference.overload_id"]; !ok {
		if len(m.OverloadId) > 0 {
			for _, v := range m.OverloadId {
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(v))))
				_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(v), len(v)))
			}
		}
	}
	if _, ok := ignore["google.api.expr.v1alpha1.Reference.value"]; !ok {
		if m.GetValue() != nil {
			google_api_expr_v1alpha1_Constant_hashpb_sum(m.GetValue(), hasher, ignore, b)
		}
	}
}

func google_api_expr_v1alpha1_SourceInfo_Extension_Version_hashpb_sum(m *v1alpha1.SourceInfo_Extension_Version, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["google.api.expr.v1alpha1.SourceInfo.Extension.Version.major"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(m.GetMajor())))
	}
	if _, ok := ignore["google.api.expr.v1alpha1.SourceInfo.Extension.Version.minor"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(m.GetMinor())))
	}
}

func google_api_expr_v1alpha1_SourceInfo_Extension_hashpb_sum(m *v1alpha1.SourceInfo_Extension, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["google.api.expr.v1alpha1.SourceInfo.Extension.id"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetId()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetId()), len(m.GetId())))
	}
	if _, ok := ignore["google.api.expr.v1alpha1.SourceInfo.Extension.affected_components"]; !ok {
		if len(m.AffectedComponents) > 0 {
			for _, v := range m.AffectedComponents {
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(v)))
			}
		}
	}
	if _, ok := ignore["google.api.expr.v1alpha1.SourceInfo.Extension.version"]; !ok {
		if m.GetVersion() != nil {
			google_api_expr_v1alpha1_SourceInfo_Extension_Version_hashpb_sum(m.GetVersion(), hasher, ignore, b)
		}
	}
}

func google_api_expr_v1alpha1_SourceInfo_hashpb_sum(m *v1alpha1.SourceInfo, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["google.api.expr.v1alpha1.SourceInfo.syntax_version"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetSyntaxVersion()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetSyntaxVersion()), len(m.GetSyntaxVersion())))
	}
	if _, ok := ignore["google.api.expr.v1alpha1.SourceInfo.location"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetLocation()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetLocation()), len(m.GetLocation())))
	}
	if _, ok := ignore["google.api.expr.v1alpha1.SourceInfo.line_offsets"]; !ok {
		if len(m.LineOffsets) > 0 {
			for _, v := range m.LineOffsets {
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(v)))
			}
		}
	}
	if _, ok := ignore["google.api.expr.v1alpha1.SourceInfo.positions"]; !ok {
		if len(m.Positions) > 0 {
			if len(m.Positions) <= 32 {
				keys := hashpb_int64KeyPool.Get().([]int64)[:0]
				for k := range m.Positions {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(k)))
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(m.Positions[k])))
				}
				hashpb_int64KeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.Positions)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(k)))
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(m.Positions[k])))
				}
			}
		}
	}
	if _, ok := ignore["google.api.expr.v1alpha1.SourceInfo.macro_calls"]; !ok {
		if len(m.MacroCalls) > 0 {
			if len(m.MacroCalls) <= 32 {
				keys := hashpb_int64KeyPool.Get().([]int64)[:0]
				for k := range m.MacroCalls {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(k)))
					if m.MacroCalls[k] != nil {
						google_api_expr_v1alpha1_Expr_hashpb_sum(m.MacroCalls[k], hasher, ignore, b)
					}
				}
				hashpb_int64KeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.MacroCalls)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(k)))
					if m.MacroCalls[k] != nil {
						google_api_expr_v1alpha1_Expr_hashpb_sum(m.MacroCalls[k], hasher, ignore, b)
					}
				}
			}
		}
	}
	if _, ok := ignore["google.api.expr.v1alpha1.SourceInfo.extensions"]; !ok {
		if len(m.Extensions) > 0 {
			for _, v := range m.Extensions {
				if v != nil {
					google_api_expr_v1alpha1_SourceInfo_Extension_hashpb_sum(v, hasher, ignore, b)
				}
			}
		}
	}
}

func google_api_expr_v1alpha1_Type_AbstractType_hashpb_sum(m *v1alpha1.Type_AbstractType, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["google.api.expr.v1alpha1.Type.AbstractType.name"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(m.GetName()))))
		_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(m.GetName()), len(m.GetName())))
	}
	if _, ok := ignore["google.api.expr.v1alpha1.Type.AbstractType.parameter_types"]; !ok {
		if len(m.ParameterTypes) > 0 {
			for _, v := range m.ParameterTypes {
				if v != nil {
					google_api_expr_v1alpha1_Type_hashpb_sum(v, hasher, ignore, b)
				}
			}
		}
	}
}

func google_api_expr_v1alpha1_Type_FunctionType_hashpb_sum(m *v1alpha1.Type_FunctionType, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["google.api.expr.v1alpha1.Type.FunctionType.result_type"]; !ok {
		if m.GetResultType() != nil {
			google_api_expr_v1alpha1_Type_hashpb_sum(m.GetResultType(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["google.api.expr.v1alpha1.Type.FunctionType.arg_types"]; !ok {
		if len(m.ArgTypes) > 0 {
			for _, v := range m.ArgTypes {
				if v != nil {
					google_api_expr_v1alpha1_Type_hashpb_sum(v, hasher, ignore, b)
				}
			}
		}
	}
}

func google_api_expr_v1alpha1_Type_ListType_hashpb_sum(m *v1alpha1.Type_ListType, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["google.api.expr.v1alpha1.Type.ListType.elem_type"]; !ok {
		if m.GetElemType() != nil {
			google_api_expr_v1alpha1_Type_hashpb_sum(m.GetElemType(), hasher, ignore, b)
		}
	}
}

func google_api_expr_v1alpha1_Type_MapType_hashpb_sum(m *v1alpha1.Type_MapType, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["google.api.expr.v1alpha1.Type.MapType.key_type"]; !ok {
		if m.GetKeyType() != nil {
			google_api_expr_v1alpha1_Type_hashpb_sum(m.GetKeyType(), hasher, ignore, b)
		}
	}
	if _, ok := ignore["google.api.expr.v1alpha1.Type.MapType.value_type"]; !ok {
		if m.GetValueType() != nil {
			google_api_expr_v1alpha1_Type_hashpb_sum(m.GetValueType(), hasher, ignore, b)
		}
	}
}

func google_api_expr_v1alpha1_Type_hashpb_sum(m *v1alpha1.Type, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if m.TypeKind != nil {
		if _, ok := ignore["google.api.expr.v1alpha1.Type.type_kind"]; !ok {
			switch t := m.TypeKind.(type) {
			case *v1alpha1.Type_Dyn:
				if t.Dyn != nil {
					google_protobuf_Empty_hashpb_sum(t.Dyn, hasher, ignore, b)
				}
			case *v1alpha1.Type_Null:
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(t.Null)))
			case *v1alpha1.Type_Primitive:
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(t.Primitive)))
			case *v1alpha1.Type_Wrapper:
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(t.Wrapper)))
			case *v1alpha1.Type_WellKnown:
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(t.WellKnown)))
			case *v1alpha1.Type_ListType_:
				if t.ListType != nil {
					google_api_expr_v1alpha1_Type_ListType_hashpb_sum(t.ListType, hasher, ignore, b)
				}
			case *v1alpha1.Type_MapType_:
				if t.MapType != nil {
					google_api_expr_v1alpha1_Type_MapType_hashpb_sum(t.MapType, hasher, ignore, b)
				}
			case *v1alpha1.Type_Function:
				if t.Function != nil {
					google_api_expr_v1alpha1_Type_FunctionType_hashpb_sum(t.Function, hasher, ignore, b)
				}
			case *v1alpha1.Type_MessageType:
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(t.MessageType))))
				_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(t.MessageType), len(t.MessageType)))
			case *v1alpha1.Type_TypeParam:
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(t.TypeParam))))
				_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(t.TypeParam), len(t.TypeParam)))
			case *v1alpha1.Type_Type:
				if t.Type != nil {
					google_api_expr_v1alpha1_Type_hashpb_sum(t.Type, hasher, ignore, b)
				}
			case *v1alpha1.Type_Error:
				if t.Error != nil {
					google_protobuf_Empty_hashpb_sum(t.Error, hasher, ignore, b)
				}
			case *v1alpha1.Type_AbstractType_:
				if t.AbstractType != nil {
					google_api_expr_v1alpha1_Type_AbstractType_hashpb_sum(t.AbstractType, hasher, ignore, b)
				}
			}
		}
	}
}

func google_protobuf_Duration_hashpb_sum(m *durationpb.Duration, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["google.protobuf.Duration.seconds"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(m.GetSeconds())))
	}
	if _, ok := ignore["google.protobuf.Duration.nanos"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(m.GetNanos())))
	}
}

func google_protobuf_Empty_hashpb_sum(m *emptypb.Empty, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
}

func google_protobuf_ListValue_hashpb_sum(m *structpb.ListValue, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["google.protobuf.ListValue.values"]; !ok {
		if len(m.Values) > 0 {
			for _, v := range m.Values {
				if v != nil {
					google_protobuf_Value_hashpb_sum(v, hasher, ignore, b)
				}
			}
		}
	}
}

func google_protobuf_Struct_hashpb_sum(m *structpb.Struct, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["google.protobuf.Struct.fields"]; !ok {
		if len(m.Fields) > 0 {
			if len(m.Fields) <= 32 {
				keys := hashpb_stringKeyPool.Get().([]string)[:0]
				for k := range m.Fields {
					keys = append(keys, k)
				}
				slices.Sort(keys)
				for _, k := range keys {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Fields[k] != nil {
						google_protobuf_Value_hashpb_sum(m.Fields[k], hasher, ignore, b)
					}
				}
				hashpb_stringKeyPool.Put(keys)
			} else {
				for _, k := range slices.Sorted(maps.Keys(m.Fields)) {
					_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(k))))
					_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(k), len(k)))
					if m.Fields[k] != nil {
						google_protobuf_Value_hashpb_sum(m.Fields[k], hasher, ignore, b)
					}
				}
			}
		}
	}
}

func google_protobuf_Timestamp_hashpb_sum(m *timestamppb.Timestamp, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if _, ok := ignore["google.protobuf.Timestamp.seconds"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(m.GetSeconds())))
	}
	if _, ok := ignore["google.protobuf.Timestamp.nanos"]; !ok {
		_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(m.GetNanos())))
	}
}

func google_protobuf_Value_hashpb_sum(m *structpb.Value, hasher hash.Hash, ignore map[string]struct{}, b *[10]byte) {
	if m.Kind != nil {
		if _, ok := ignore["google.protobuf.Value.kind"]; !ok {
			switch t := m.Kind.(type) {
			case *structpb.Value_NullValue:
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(t.NullValue)))
			case *structpb.Value_NumberValue:
				_, _ = hasher.Write(protowire.AppendFixed64(b[:0], math.Float64bits(t.NumberValue)))
			case *structpb.Value_StringValue:
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], uint64(len(t.StringValue))))
				_, _ = hasher.Write(unsafe.Slice(unsafe.StringData(t.StringValue), len(t.StringValue)))
			case *structpb.Value_BoolValue:
				_, _ = hasher.Write(protowire.AppendVarint(b[:0], protowire.EncodeBool(t.BoolValue)))
			case *structpb.Value_StructValue:
				if t.StructValue != nil {
					google_protobuf_Struct_hashpb_sum(t.StructValue, hasher, ignore, b)
				}
			case *structpb.Value_ListValue:
				if t.ListValue != nil {
					google_protobuf_ListValue_hashpb_sum(t.ListValue, hasher, ignore, b)
				}
			}
		}
	}
}
