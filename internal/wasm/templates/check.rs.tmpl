{{define "check"}}
    #[wasm_bindgen]
    pub fn check(val: JsValue) -> Result<String, JsValue> {
        match val.into_serde::<Request>() {
            Ok(req) => Ok(check_impl(req)),
            Err(e) => Err(JsValue::from_str(&e.to_string()))
        }
    }
    fn check_impl(request: Request) -> String {
        let roles: Vec<_> = request.principal.roles.iter().map(AsRef::as_ref).collect();
        {{- if .DerivedRoles  }}
        let mut dr: Vec<&str> = Vec::new();
        {{ range $dr := .DerivedRoles }}
        if intersect(&roles, &vec![{{template "join-string-slice" $dr.ParentRoles}}]) {
        {{- if $dr.Condition }}
            if {{$dr.RenderCondition}} {
                dr.push({{printf "%q" $dr.Name}})
            }
        {{- else}}
            dr.push({{printf "%q" $dr.Name}}){{end}}
        }
        {{- end}}
        {{- end}}
        let allow = "EFFECT_ALLOW".to_owned();
        let deny = "EFFECT_DENY".to_owned();
        {{range $rule := .Rules }}
        if {{ if $rule.Roles }}intersect(&roles, &vec![{{template "join-string-slice" $rule.Roles}}]){{end}}
        {{- if $rule.DerivedRoles }}{{if $rule.Roles}} || {{end}}intersect(&dr, &vec![{{template "join-string-slice" $rule.DerivedRoles}}]){{end}} {
            if action_matched(&request.action, &vec![{{template "join-string-slice" $rule.Actions}}]) {
            {{- if $rule.Condition }}
                if {{$rule.RenderCondition}} {
                    return {{template "effect" $rule.Effect}};
                }
            {{- else}}
                return {{template "effect" $rule.Effect}};{{end}}
            }
        }
        {{- end}}

        return deny;
    }
{{end}}